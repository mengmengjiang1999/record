# week6-20250324-20250330

20250326

通过阅读代码，知道了glue_generator的用法，给它喂正确的argc就可以了。

20250327

通过阅读代码，发现至少要三次loop之后才进入main循环。在进入main循环之前，glueVars更改了input的指针。所以input数据需要至少glueVars执行完了之后才能进行更改。

总之race问题的触发和检测方式已经找到了。

下一步就是进行模糊测试的问题。下一步就是把race问题跟模糊测试的这部分接起来。


qemu的初始测试用例应该是有趣的测试用例，但是不应该直接导致崩溃。

[-] Oops, the program crashed with one of the test cases provided. There are
    several possible explanations:

    - The test case causes known crashes under normal working conditions. If
      so, please remove it. The fuzzer should be seeded with interesting
      inputs - but not ones that cause an outright crash.

    - In QEMU persistent mode the selected address(es) for the loop are not
      properly cleaning up variables and memory. Try adding
      AFL_QEMU_PERSISTENT_GPR=1 or select better addresses in the binary.

    - Least likely, there is a horrible bug in the fuzzer. If other options
      fail, poke the Awesome Fuzzing Discord for troubleshooting tips.

这段话是AFL（American Fuzzy Lop）在模糊测试过程中遇到程序崩溃时给出的提示信息。它解释了可能导致崩溃的几种情况，并提供了一些解决方法。以下是详细解释：

### 1. **测试用例导致已知崩溃**
   - **解释**：提供的测试用例在正常工作条件下就会导致程序崩溃。这意味着这些测试用例本身就有问题，而不是模糊测试工具发现的新问题。
   - **解决方法**：从初始测试用例中移除这些导致崩溃的测试用例。模糊测试工具应该使用有趣的输入来启动，但这些输入不应该直接导致程序崩溃。

### 2. **QEMU持久模式下的问题**
   - **解释**：在QEMU持久模式下，选择的循环地址没有正确清理变量和内存。这可能导致程序在多次执行时出现崩溃。
   - **解决方法**：
     - 尝试设置环境变量`AFL_QEMU_PERSISTENT_GPR=1`。这个变量可以帮助QEMU更好地管理通用寄存器（GPR），从而减少因寄存器状态不一致导致的崩溃。
     - 选择更好的地址。如果当前选择的地址不适合持久模式，可以尝试选择其他地址。可以通过分析目标程序的二进制文件来找到更合适的地址。

### 3. **模糊测试工具的潜在问题**
   - **解释**：虽然这种情况比较少见，但也不能完全排除模糊测试工具本身存在严重问题的可能性。
   - **解决方法**：
     - 如果其他方法都失败了，可以尝试联系AFL社区或在Awesome Fuzzing Discord群组中寻求帮助。社区成员或开发者可能会提供一些故障排除的建议。

### 总结
这段话的主要目的是帮助用户理解在模糊测试过程中遇到程序崩溃时可能的原因，并提供一些解决方法。通过逐步排查这些可能的原因，可以更好地定位和解决问题，从而提高模糊测试的效率和效果。

### 示例操作
1. **移除导致崩溃的测试用例**：
   - 检查初始测试用例目录，找到导致崩溃的测试用例文件并移除：
     ```bash
     rm /path/to/initial/corpus/seed_4
     ```

2. **设置环境变量`AFL_QEMU_PERSISTENT_GPR=1`**：
   - 在运行AFL-QEMU时，设置环境变量：
     ```bash
     export AFL_QEMU_PERSISTENT_GPR=1
     ```

3. **选择更好的地址**：
   - 分析目标程序的二进制文件，找到更合适的地址。这可能需要使用工具如`objdump`或`gdb`来查看程序的内存布局和执行路径。

4. **寻求社区帮助**：
   - 如果问题仍然无法解决，可以在Awesome Fuzzing Discord群组中寻求帮助。
  

需要更好地选择

输入的种子其实是在模拟plc的输入数据。


1. 建立输入数据结构



在不加入静态分析的时候，平均每次输入数据变异用时非常久。


下面这部分是修改的代码。


//-----------------------------------------------------------------------------
// Copyright 2015 Thiago Alves
//
// Based on the LDmicro software by Jonathan Westhues
// This file is part of the OpenPLC Software Stack.
//
// OpenPLC is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OpenPLC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with OpenPLC.  If not, see <http://www.gnu.org/licenses/>.
//------
//
// This file is the hardware layer for the OpenPLC. If you change the platform
// where it is running, you may only need to change this file. All the I/O
// related stuff is here. Basically it provides functions to read and write
// to the OpenPLC internal buffers in order to update I/O state.
// Thiago Alves, Dec 2015
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include<iostream>

#include "ladder.h"
#include "custom_layer.h"
#include "crash_check.h"

#include "input_data_simulator.h"

static BufferHistory bool_history;

// static BufferHistory output_history;

//-----------------------------------------------------------------------------
// This function is called by the main OpenPLC routine when it is initializing.
// Hardware initialization procedures should be here.
//-----------------------------------------------------------------------------

void initializeHardware()
{
	// initialize bool input and output buffers
	printf("Initializing hardware layer...\n");
	for(int i = 0; i < BUFFER_SIZE; i++){
		for(int j = 0; j < 8; j++){
			bool_input[i][j] = new IEC_BOOL;
		}
	}

	for(int i = 0; i < BUFFER_SIZE; i++){
		for(int j = 0; j < 8; j++){
			bool_output[i][j] = new IEC_BOOL;
		}
	}

	bool_history.updateBoolHistory(bool_input,bool_output);

}

//-----------------------------------------------------------------------------
// This function is called by the main OpenPLC routine when it is finalizing.
// Resource clearing procedures should be here.
//-----------------------------------------------------------------------------
void finalizeHardware()
{
}

//-----------------------------------------------------------------------------
// This function is called by the OpenPLC in a loop. Here the internal buffers
// must be updated to reflect the actual Input state. The mutex bufferLock
// must be used to protect access to the buffers on a threaded environment.
//-----------------------------------------------------------------------------



// 写输入数据，从标准输入中模拟

void showInput(){
	std::cout << "Input values:\n";
	for(int i = 0; i < BUFFER_SIZE; i++){
		for(int j = 0; j < 8; j++){
			printf("%d,%d, %hhu\n", i, j, *bool_input[i][j]);
		}
		std::cout << std::endl;
	}
}


// 旧版的updateBuffersIn，从标准输入中读取数据，并写入到bool_input中
void updateBuffersIn(int t)
{
	// printf("Get input values:\n");
	pthread_mutex_lock(&bufferLock); //lock mutex

	/*********READING AND WRITING TO I/O**************

	*bool_input[0][0] = read_digital_input(0);
	write_digital_output(0, *bool_output[0][0]);

	*int_input[0] = read_analog_input(0);
	write_analog_output(0, *int_output[0]);

	**************************************************/

	for(int i = 0; i < BUFFER_SIZE; i++){
		for(int j = 0; j < 8; j++){
			IEC_BOOL value;
			// std::cin>>value;
			if(scanf("%hhu", &value) != 1){
			}else{
				printf("Input buffer: %d,%d, %hhu\n", i, j, value);
				*bool_input[i][j] = value;
			}
		}
	}

	// bool_history.updateBoolHistory(bool_input,bool_output);
	// bool_history.printHistory();

	// showInput();

	pthread_mutex_unlock(&bufferLock); //unlock mutex
}


// 新版本的updateBuffersIn，从输入数
void updateBuffersIn()
{
	// printf("Get input values:\n");
	pthread_mutex_lock(&bufferLock); //lock mutex

	/*********READING AND WRITING TO I/O**************

	*bool_input[0][0] = read_digital_input(0);
	write_digital_output(0, *bool_output[0][0]);

	*int_input[0] = read_analog_input(0);
	write_analog_output(0, *int_output[0]);

	**************************************************/

	for(int i = 0; i < BUFFER_SIZE; i++){
		for(int j = 0; j < 8; j++){
			IEC_BOOL value;
			// std::cin>>value;
			if(scanf("%hhu", &value) != 1){
			}else{
				printf("Input buffer: %d,%d, %hhu\n", i, j, value);
				*bool_input[i][j] = value;
			}
		}
	}

	// bool_history.updateBoolHistory(bool_input,bool_output);
	// bool_history.printHistory();

	// showInput();

	pthread_mutex_unlock(&bufferLock); //unlock mutex
}


//-----------------------------------------------------------------------------
// This function is called by the OpenPLC in a loop. Here the internal buffers
// must be updated to reflect the actual Output state. The mutex bufferLock
// must be used to protect access to the buffers on a threaded environment.
//-----------------------------------------------------------------------------
void updateBuffersOut()
{
	// printf("update output values:\n");
	pthread_mutex_lock(&bufferLock); //lock mutex

	// printf("in mutex output values\n");

	/*********READING AND WRITING TO I/O**************

	*bool_input[0][0] = read_digital_input(0);
	write_digital_output(0, *bool_output[0][0]);

	*int_input[0] = read_analog_input(0);
	write_analog_output(0, *int_output[0]);

	**************************************************/

	// showInput();

	bool_history.updateBoolHistory(bool_input,bool_output);
	// bool_history.printHistory();

	// printf("out mutex output values\n");

	pthread_mutex_unlock(&bufferLock); //unlock mutex

	// printf("end update output values\n");
}



bool checkOutputChange(){
	return bool_history.checkChange();
}
