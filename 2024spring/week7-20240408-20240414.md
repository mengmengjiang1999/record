# week7

20240408-20240414

- LibAFL QEMU
- LibAFL
- kAFL
- fuzzing-101
- libafl/fuzzers

pip3 install "git+https://github.com/unicorn-engine/unicorn@e76b2db434382f59661471faae02b022a3ee5a30#subdirectory=bindings/python/"

### fuzzing-101

（在另一篇）

### 对baby_fuzzer的分析：

baby_fuzzer想要做的事情是fuzz一段代码，具体而言就是：main.rs中的harness部分。这段代码的功能是如果一个字符串的长度大于等于3而且开头是abc，那么就panic。当然这个是人手动写出来有bug的内容，但是现在fuzzing希望做的事情就是假设不知道用户在哪里会有bug，然后希望我们能触发这段bug。

总之我们写完harness之后测试一下，发现这段代码加进去，确实会导致harness产生panic。

```rust
    let input = BytesInput::new("abc".as_bytes().to_owned());
    harness(&input);
```

baby_fuzzer把准备进行测试的代码和fuzzing部分的代码都写在了一个main.rs里（可能这就是叫做baby的原因吧）在被测试的代码后面就是一串的定义observer，feedback，等等的代码，都封装得很好了。最后进入fuzz_loop。

在这个例子里面coverage map是写代码的人手动在代码里面建立的。在不同分支里面写signals_set，然后signal会作为参数传给observer。

剩下的流程就和普通fuzzing流程一样了，因为封装得真的很好。

另外，还提供了一个python版本的代码，实现的功能和rust版本是一致的。


顺便问下baby_no_std和baby_fuzzer有什么区别？我感觉就是在use的crate上有一些区别吧，其他没什么区别啊。


git submodule update --recursive

http.check-revoke = false

### fuzzing用户态libos形态的zcore


如果是fuzzing用户态libos的zcore的话，应该不需要no_std了

1. 编译出zcore的libos

编译流程：

```
make rootfs
cd zCore
cargo run --release --features "linux libos"
```
运行的话，编译出来的zCore二进制文件放在`./target/release`文件夹下面。zCore会认为`./rootfs/x86_64`为它的默认根目录。
要运行随便一个什么Linux程序（比如busybox）的话，命令是
```
./target/release/zcore /bin/busybox
```
实际上运行的是`./rootfs/x86_64/bin/busybox`而不是host机器上真正的busybox。

ps：
在编译的时候可能会遇到各种版本问题。具体表现是，会报错某个crate被重复use而且产生了冲突之类的，但是遇到这种情况不需要改代码，只要检查一下rustup版本，rustc版本是否正确。然后我也不知道了TT因为我遇到的问题甚至自己不知道是怎么解决的，好像什么都没有做就搞完了。

总之如果不确定是否为环境问题，本目录下提供了编译好的二进制文件以及sha256。

2. 找到一个合适的用来抄的例子。

首先我们肯定不希望去改zCore。
然后希望能实现自动的覆盖率引导，像baby_fuzzer里面那种手动插桩的方式就请不要再出现了

baby_fuzzer: too simple

baby_fuzzer_gramatron: 生成具有合法语法的输入。很厉害不过跟我们目前没什么关系。

baby_fuzzer_grimoire：完全自动覆盖率引导的fuzzer（todo，值得详细研究）

baby_fuzzer_minimizing：演示如何裁剪测试用例（看起来也很厉害）

baby_fuzzer_multi：for targets with multipart inputs.

baby_fuzzer_nautilus：a coverage-guided and grammar-based fuzzer。有一个grammar.json用来说明这个语法是什么情况。

baby_fuzzer_swap_differential：create a libafl-based differential fuzzer which swaps out the AFL map during
execution so that both maps may be measured. 这是什么意思？

baby_fuzzer_tokens：没看懂但是感觉没啥用

baby_fuzzer_unicode：感觉也没什么用

baby_fuzzer_wasm：测试wasm的，WebAssembly（简称Wasm）是一种为网络浏览器设计的低级字节码格式（什么什么的）总之没什么关系

baby_fuzzer_with_forkexecutor：?它在干嘛。反正是生成了很多个crash用例但是···

baby_no_std：

backtrace_baby_fuzzers: 有用，展示了一些基础操作。例如：如何fuzzing二进制文件，如何fuzzing C/Rust程序等等。我比较感兴趣的是里面command_executor这个测试用例。其中build.rs是将test_command.c编译成可执行文件，然后main.rs里面写的是对可执行文件进行fuzzing的流程。不过我查看了一下test_command.c，这个里面有对共享内存进行修改的环节，也就是说插桩还是要手动进行的嘛。总觉得这个操作怪怪的

forkserver_libafl_cc：todo感觉这个很重要。但是搞不明白怎么运行的。【todo】看起来真的很重要

forkserver_simple：这个应该可以做到不需要修改源代码就进行fuzzing。所以怎么做到的？【todo】

frida_executable_libpng：用来fuzzing png的，感觉没什么关系。

frida_gdiplus：也是

frida_libpng：同理

fuzzbench：



报告了一些warning，感觉问题稍微有点严重。todo

warning: libafl_targets@0.11.2: Compiler version doesn't include clang or GCC: "cc" "--version"
warning: libafl_targets@0.11.2: Compiler version doesn't include clang or GCC: "cc" "--version"
warning: libafl_targets@0.11.2: Compiler version doesn't include clang or GCC: "cc" "--version"
warning: libafl_targets@0.11.2: Compiler version doesn't include clang or GCC: "cc" "--version"
warning: libafl_cc@0.11.2: Skipping src/dump-cfg-pass.cc
warning: libafl_cc@0.11.2: Compiler version doesn't include clang or GCC: "cc" "--version"
    Finished `release` profile [optimized + debuginfo] target(s) in 43.04s

### 论文

LibAFL: A Framework to Build Modular and Reusable Fuzzers。详情见papers/LibAFL: A Framework to Build Modular and Reusable Fuzzers.md

简而言之我的评价是，值得关注的点有几个：

1. 这个工作的亮点

+ Rust写的
+ 组件化fuzzing框架
+ 方便对不同的fuzzing策略进行评估和对比，方便把新的策略融合进来
+ 可以对裸机程序进行fuzzing

2. 第三章对fuzzing的总体结构的介绍

3. 第五章实验部分。实验部分先提出fuzzing里面的几个关键技术，然后说明LibAFL框架如何能做到把这些关键技术融合进来。这些关键技术基本上都是算法层面，roadblocks bypassing (e.g., [6, 17, 57, 62]), structure-aware fuzzing (e.g., [4, 10, 25, 59]), corpus scheduling (e.g., [18, 21, 72, 73]) and energy assignment (e.g., [12–14, 43]). 关注的问题都是如何更好更高效地生成有效测试用例。


第四章的话，大概可以被看成是一个仓库的文档。

