# week7

20240408-20240414

- LibAFL QEMU
- LibAFL
- kAFL
- fuzzing-101
- libafl/fuzzers

pip3 install "git+https://github.com/unicorn-engine/unicorn@e76b2db434382f59661471faae02b022a3ee5a30#subdirectory=bindings/python/"

### fuzzing-101

（在另一篇）

### 对baby_fuzzer的分析：

baby_fuzzer想要做的事情是fuzz一段代码，具体而言就是：main.rs中的harness部分。这段代码的功能是如果一个字符串的长度大于等于3而且开头是abc，那么就panic。当然这个是人手动写出来有bug的内容，但是现在fuzzing希望做的事情就是假设不知道用户在哪里会有bug，然后希望我们能触发这段bug。

总之我们写完harness之后测试一下，发现这段代码加进去，确实会导致harness产生panic。

```rust
    let input = BytesInput::new("abc".as_bytes().to_owned());
    harness(&input);
```

baby_fuzzer把准备进行测试的代码和fuzzing部分的代码都写在了一个main.rs里（可能这就是叫做baby的原因吧）在被测试的代码后面就是一串的定义observer，feedback，等等的代码，都封装得很好了。最后进入fuzz_loop。

在这个例子里面coverage map是写代码的人手动在代码里面建立的。在不同分支里面写signals_set，然后signal会作为参数传给observer。

剩下的流程就和普通fuzzing流程一样了，因为封装得真的很好。

另外，还提供了一个python版本的代码，实现的功能和rust版本是一致的。


顺便问下baby_no_std和baby_fuzzer有什么区别？我感觉就是在use的crate上有一些区别吧，其他没什么区别啊。


git submodule update --recursive

http.check-revoke = false

### fuzzing用户态libos形态的zcore


如果是fuzzing用户态libos的zcore的话，应该不需要no_std了

1. 编译出zcore的libos

编译流程：

```
make rootfs
cd zCore
cargo run --release --features "linux libos"
```
运行的话，编译出来的zCore二进制文件放在`./target/release`文件夹下面。zCore会认为`./rootfs/x86_64`为它的默认根目录。
要运行随便一个什么Linux程序（比如busybox）的话，命令是
```
./target/release/zcore /bin/busybox
```
实际上运行的是`./rootfs/x86_64/bin/busybox`而不是host机器上真正的busybox。

ps：
在编译的时候可能会遇到各种版本问题。具体表现是，会报错某个crate被重复use而且产生了冲突之类的，但是遇到这种情况不需要改代码，只要检查一下rustup版本，rustc版本是否正确。然后我也不知道了TT因为我遇到的问题甚至自己不知道是怎么解决的，好像什么都没有做就搞完了。

总之如果不确定是否为环境问题，本目录下提供了编译好的二进制文件以及sha256。

2. 找到一个合适的用来抄的例子。

首先我们肯定不希望去改zCore。
然后希望能实现自动的覆盖率引导，像baby_fuzzer里面那种手动插桩的方式就请不要再出现了

baby_fuzzer: too simple
baby_fuzzer_gramatron: 生成具有合法语法的输入。很厉害不过跟我们目前没什么关系。
baby_fuzzer_grimoire：完全自动覆盖率引导的fuzzer（todo，值得详细研究）
baby_fuzzer_minimizing：演示如何裁剪测试用例（看起来也很厉害）
baby_fuzzer_multi：for targets with multipart inputs.
baby_fuzzer_nautilus：