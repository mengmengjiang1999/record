
# From Library Portability to Para-rehosting: Natively Executing Microcontroller Software on Commodity Hardware


## 先介绍对于固件进行fuzzing的四种不同的方式，以及进行对比。
为了检验MCU固件的安全性，已经讨论了几种方法。我们将它们归类为四类。
1) 设备上的分析：这种方法需要真实设备来进行测试。它得到了最真实可信的结果，但可扩展性较差，且缺乏可见性。在裸机上收集执行信息是困难的。
2) 完整仿真：为了克服真实硬件上的性能和可扩展性问题，研究人员提出了使用如QEMU这样的完整仿真器来模拟固件执行。主要挑战是仿真不同的外设，并且已经有一些努力朝着这个目标前进[25]，[28]。理论上，这种方法能够更好地观察固件执行。不幸的是，据我们所知，目前还没有工作能够精确支持以前未知的设备。因此，目前，这种方法只存在于理想化的设置中。
3) 外设转发：作为一种中间地带的解决方案，混合方法将外设访问转发到真实设备，并将固件在仿真器内运行[60]，[43]，[34]。然而，由于依赖真实硬件，性能和可扩展性问题仍未解决。
4) 半重新托管：在像HALucinator [16]这样的半重新托管解决方案中，固件的主要逻辑仍然在仿真器内执行。然而，高级HAL函数被识别出来，并用主机上的重新托管处理器替换。因此，避免了对多样化外设的复杂建模。


## rehosting有很多的好处：

rehosting：将MCU软件重新编译，使得在用户态可以执行，根据论文描述，好处有至少3个：

1. 现成的x86动态分析工具可以立即开箱即用。
2. 与在真实的MCU设备上运行相比，可以同时启动多个实例，允许进行可扩展和并行的分析。
3. 商品硬件比MCU设备强大得多。我们可以在更短的时间内执行更多的测试用例。


通过一些人工的工作，可以将MCU移植到特定的主机机器。

## 但是目前存在的困难是：

在MCU工具链中使用的libc（例如newlib和redlib）与像GNU libc这样的完整libc实现相比，设计不同。例如，ARM Mbed OS使用函数software_init_hook()来执行一些针对目标的早期初始化，这在GNU libc中并未定义；
更重要的是，一个单一的库有时与一组支持的操作系统例程混合在一起，这些例程也必须被移植；
这些例程是受调度的。如果不考虑到调用序列，预期的逻辑很容易被违反；
如果重新托管的代码需要访问MCU上的真实硬件，那么在主机上的行为就会变得不可预测。

总之，这些困难使得直接移植代价很高，而且相比之下取得的收益有限，而且不具备可迁移性。


## 本文提出了一种全新的para-rehosting的方案

MCU固件的内部安全测试对物联网安全至关重要。然而，由于测试环境的不同，MCU固件无法使用x86上的复杂工具。
将固件重新编译到本地x86主机可以直接解决这个问题。然而，特别定制的移植工作令人畏惧，容易出错，有时甚至是不可能的。因此，我们提出了pararehosting（部分重新托管）来简化这一过程。可移植的MCU能够模拟MCU的通用功能，而paraAPIs则方便了基于HAL（硬件抽象层）的外设函数替换，以处理外设。直接重新托管MCU操作系统可以解决现有解决方案面临的基本问题（性能、可扩展性和可见性）。我们已经实现了我们的想法，并重新托管了九个MCU操作系统。我们对Amazon FreeRTOS、ARM Mbed OS、Zephyr和LiteOS的库进行了安全测试。这些操作系统附带的大多数库可以通过现成的动态分析工具进行测试，包括AFL和ASAN。我们的实验表明，真实固件中的错误可以在重新托管的固件中复现，并且错误在重新托管的固件中更易于观察。通过使用模糊测试运行我们的工具，已经发现了以前未知的错误。


本文提出了pararehosting技术，pararehosting（部分重新托管），旨在使MCU软件重新托管到商品硬件的过程更加顺畅。与特别定制的库移植不同，我们支持完全移植MCU操作系统核心，并允许增量即插即用库移植。具体来说，我们抽象了大多数MCU操作系统遵循的整个机器模型，并使用可移植操作系统接口（POSIX）实现了它（命名为PMCU）。通过一个薄薄的操作系统特定的粘合层，PMCU可以与上层源代码（包括库和任务）一起编译成主机上的普通用户空间程序。PMCU准确地模拟了真实MCU的常见行为。因此，基本的操作系统原语，包括调度、抢占、原子性等，可以自动得到支持。简而言之，就是将以上过程自动化完成。

B. Para-rehosting
我们提出pararehosting（部分重新托管）以简化MCU软件移植的复杂性。在pararehosting中，我们在主机机器上提供了模拟处理器和外设行为的通用后端实现。上层软件只需要进行轻微的修改以适应后端。
通过pararehosting，我们可以将整个RTOS逻辑，包括内核、内置任务、普通任务一起编译成一个单一的主机程序。它们共享主机上一个进程的相同虚拟地址空间，就像它们在真实MCU上共享相同的平面物理地址空间一样。
如图2所示，所提出的系统由两个主要组件组成。可移植的MCU（PMCU）是一个主机后端，模拟MCU的通用功能和其上可用的内存资源。它可以轻松地移植到不同的MCU操作系统上。具体来说，PMCU模拟任务调度和系统时钟。它还为MCU操作系统提供基本的同步原语。所有这些功能对于MCU操作系统都是必不可少的。我们的实现是模块化的。每个抽象模块都放置在单独的C源文件中，并在需要时在编译项目期间包含在项目中。对于每个支持的MCU操作系统，都有一个薄的粘合层来适应特定的操作系统需求。此外，我们使用链接器脚本来管理结果程序的布局，使其类似于在真实设备上的布局。有了PMCU，我们可以准确地重新托管一个不依赖于任何特定硬件外设的MCU固件。
另一个组件，称为基于HAL的外设函数替换，处理特定于硬件的外设逻辑。
因此，它解决了硬件依赖性问题。由于HAL从程序员那里抽象出低级硬件细节，我们可以很容易地将其高级功能替换为等效的处理程序。请注意，来自不同供应商的设备的HAL通常是不同的。我们不能简单地实现一个高级替换并将其用于所有设备。我们通过将HAL函数的语义实现为一个通用后端，并要求每个HAL库进行一些手动工作来调用后端驱动程序来解决这个问题。相应地，需要适当调整参数并正确捕获返回值。

## 具体设计

### A. 抽象机器功能
1) 任务管理：不同于传统的MCU系统，其中单个任务独占处理器，在物联网时代，各种任务需要同时运行。这就需要一个多程序环境。多任务支持已成为主要MCU操作系统的标准特性，PMCU需要相应地模拟这些特性。
我们使用Linux中的一个进程来模拟整个MCU固件，使用一个线程来模拟一个任务。Linux的线程-进程模型为模拟MCU的任务-固件模型提供了基础。特别是，在Linux中，所有线程共享同一个进程的虚拟内存空间，并且拥有自己的栈。在MCU固件中，所有任务共享同一个MCU的物理内存空间，并拥有自己的栈。
在PMCU中，当MCU操作系统创建一个任务时，就会创建一个pthread（线程），其start_routine（开始例程）被初始化为任务的起始函数。线程切换也因为pthread库负责保存和恢复上下文而得到透明支持。在大多数MCU操作系统中，由于多核支持不成熟[41]，[48]，在特定时间只能执行一个线程。因此，我们需要确保一个线程独占当前进程。
也就是说，尽管概念上有多个线程，但只有一个线程是可运行的。这是通过使用POSIX中的信号和互斥机制的组合实现的。只有持有互斥锁的线程才被允许执行。当当前线程让出或被抢占时，它解锁互斥锁以允许其他线程执行，并通过调用sig_wait()挂起自身。
为了恢复，它必须在相应的信号处理程序中接收信号SIGUSR1并获取相同的互斥锁。
默认情况下，在创建线程时，pthread库会分配一个内存区域用作栈，这超出了控制范围。在第四部分B节中，我们将解释如何确保任务栈的位置在真实MCU的内存映射内。

简而言之就是，使用Linux进程来模拟MCU固件，使用线程来模拟一个task。在MCU操作系统中，特定时间只能支持一个线程。对应地，使用互斥锁机制确保一个线程独占当前进程。

2) 系统时钟：MCU的时间被多个任务同时共享。通常使用一个定时器，称为系统时钟（system tick），来定期调用调度器以切换任务。为了支持抢占，RTOS内核会被一个系统定时器定期唤醒，这在真实的MCU中通常由一个计数器硬件实现。自然地，我们利用POSIX中的系统定时器来定期引发一个定时器信号，以模拟这一过程。具体来说，我们使用setitimer()来定期发送一个SIGVTALRM类型的ITIMER_VIRTUAL信号。
ITIMER_VIRTUAL定时器对进程中所有线程消耗的用用户模式CPU时间进行倒计时。因此，它避免了由于对进程分配的不可预测时间所导致的问题。在SIGVTALRM信号处理程序内部，PMCU调用调度器来恢复下一个任务。请注意，调度算法和任务优先级对PMCU来说完全是透明的。请注意，由于Linux机器上定时器的不可预测行为，我们不能保证每次模拟都产生完全相同的执行路径。在真实设备上也是如此。我们稍后将证明，在实践中，这种非确定性行为并不影响错误发现。


3) 同步原语：同步是操作系统的一个基本原语。一旦违反，执行可能会崩溃。例如，当一个任务进入临界区时，一些RTOS需要禁用中断（包括系统时钟）。如果PMCU允许在临界区内有系统时钟（从而允许任务调度），可能会发生竞态条件。PMCU通过在一个全局变量PMCU_INT_ENABLED中跟踪当前中断状态来模拟禁用中断。
当SIGVTALRM信号发生时，如果PMCU_INT_ENABLED被清除，处理程序会立即返回，并将PMCU_pending变量设置为表明在退出临界区后应该调用调度器。否则，处理程序执行正常的调度过程。此外，PMCU确保它不干扰RTOS内核本身，因为PMCU也需要访问关键的RTOS数据结构。
4) 一个运行示例：在图3中，我们展示了一个MCU操作系统执行的运行示例，包含两个任务。任务1正在执行，直到t0时刻，一个SIGVTALRM信号发生，请求可能的任务切换。然后处理程序介入（由PMCU代表）调用内核中的systick处理程序（t0-t1）。内核中的处理程序选择下一个任务并发送一个信号SIGUSR1（t1-t2）。信号处理程序简单地将对应于被选任务（任务2）的线程调度为可运行（t2-t3）。结果，任务2从t3开始执行。从t4到t7的执行序列不言自明。


### B. 内存布局强制

这部分也是重点

如前所述，重新托管程序的内存布局（包括代码、数据、栈、bss等）与真实设备中的不同。例如，默认的Linux机器上的链接器将x86-32上的代码段从0x08048000开始放置，而x86-64上从0x400000开始（如果未启用PIE），而MCU编译器的链接器通常将代码段从零开始放置。这由一个称为链接器脚本的文件控制。通常，MCU有一个从零开始的闪存存储器和另一个偏移处的独立SRAM。为了能够更准确地捕获由内存错误引起的程序错误行为，我们需要根据MCU中的内存映射放置代码和数据段。我们可以简单地重用MCU固件中可用的链接器脚本，但是出现了三个问题。
首先，Linux程序的栈是由内核分配的，而不是基于链接器脚本。具体来说，栈在x86-32上从0x7FFFFFFF向下增长，在x86-64上从0x7fbFFFFFFF向下增长（不考虑随机化）。
此外，默认的线程栈大小限制为2MB。
这个数字甚至超过了许多MCU上的总SRAM大小。为了解决这个问题，我们用汇编语言实现了一个名为stack_switching(void *newSP, void *newFun)的跳板函数，该函数显式地操作SP寄存器，以便线程使用新指定的栈。
然后它跳转到函数newFun()。我们将新任务的开始例程（比如start_routine()）包装在stack_switching(newSP,start_routine)中，这样函数就将栈切换到基于MCU链接器脚本分配的栈，然后跳转到真正的开始函数start_routine()。我们注意到，使用makecontext/setcontext API也可以达到类似的结果。
其次，MCU操作系统中的堆管理与Linux中的冲突。MCU libc分配器没有实现底层的_sbk()，而是依赖于开发者根据链接器脚本中指定的堆范围提供特定于设备的实现。因此，提供的_sbk()与Linux libc分配器中的冲突。在这里我们有两个选择。首先，我们可以抑制Linux分配器。通过这种方式，我们可以精确地模拟链接器脚本中指定的堆布局。其次，我们可以抑制固件提供的_sbk()并使用Linux版本。通过这种方式，我们牺牲了对内存布局的精确仿真。这可能会导致在错误重现和利用中出现问题。然而，使用Linux分配器允许我们立即获得ASAN的bug发现能力。
一些MCU操作系统（如FreeRTOS和LiteOS）提供了自己的分配器。对于它们，我们也有两大策略；1)我们可以将它们的堆实现替换为Linux上的实现，但牺牲了定制分配器的覆盖范围；2)我们可以保留它们的实现，但牺牲ASAN在堆中发现内存错误的能力。
最后，MCU程序的入口点是函数Reset_Hander()，而不是常规Linux程序中的__start()。__start()执行执行环境的必要初始化，并跳转到main函数，而Reset_Hander()在真实设备的内存映射上初始化模拟的内存，例如将数据段从“flash”复制到“SRAM”。我们保持重新托管程序的入口点为__start()，但在执行main函数之前明确调用修改后的Reset_Hander()。

### 关于外设

I/O：将 MCU 固件的外设 I/O 映射到主机的标准 I/O，特别是控制台。此外，为了支持网络功能的模拟，开发了一个基于 PCAP 库的高保真网络后端，允许固件访问互联网并处理网络数据包。通过这种方式，可以使用模糊测试工具向固件提供输入，并在主机环境中模拟 MCU 外设的行为。

存储外设：通过文件来存储固件的整个文件系统。在启动的时候会将文件内容映射到内存中，然后通过读写内存来模拟文件访问操作。

计算加速器外设：计算加速器外设提供了流行算法的硬件辅助实现，包括许多加密算法和随机数生成器。我们主要使用OpenSSL库来模拟这些算法，并将结果传递给前端函数。

虚拟外设：虚拟外设通常不执行可能影响固件执行的操作。因此，只返回true或者void


## 关于实验：EVALUATION

实现了一个para-rehosting原型系统。这个系统想要适配一个新的MCU操作系统，只需要大概50行代码。

测试的这部分，主要是为了测试：

### A. 重新托管能力
这部分测试的是论文给出的原型系统，对于软件栈的支持能力。统计了不同的MCU OS的库信息，并且统计了原型系统支持多少库。可以看出这个比例是非常大的。

本节描述了所提出系统的重新托管能力。如前所述，MCU生态系统通常提供一个全面的软件栈以吸引开发者和制造商。我们从相应的官方文档页面或Github仓库中获取了包括Amazon FreeRTOS、ARM Mbed OS、Zephyr和LiteOS在内的四种代表性MCU操作系统的库信息，并统计了我们的原型支持的库。结果总结在表VI中。我们的原型分别支持FreeRTOS、ARM Mbed OS、Zephyr和LiteOS附带的所有库的84.21%、76.47%、89.47%和63.64%。
我们还总结了两个流行的MCU芯片供应商STMicroelectronics和NXP支持的HAL函数。
这个统计数据表明了我们的原型可以支持多少个外设。结果总结在表VIII中。
在表中，我们还列出了每个外设的相关前端和后端函数。值得一提的是，在将源代码与PMCU和HAL后端粘合后，我们没有发现任何编译失败的情况。特别是，在MCU库中没有发现特定于架构的汇编代码。这部分是因为硬件中立的MCU库已经在MCU生态系统中得到了广泛采用。

### B. Fuzzing Performance

这部分要测试的是，这个工作是否真的可以对fuzzing有所帮助。
挑选了合适的库进行测试，并且详细说明了挑选的标准，总之最后挑中了FreeRTOS+TCP library这个库。
经过测试，fuzzing48小时后，成功复现了FreeRTOS+TCP library已报告bug的13个bug中的9个。

和其他工作进行对比：

1. 与基于仿真的工作进行对比

只考虑了应用程序和MCU库的代码。在所有测试样本中，我们都实现了更高的基本块覆盖率。这可以通过我们的方法带来的巨大加速来解释。

2. Comparison with On-device Analysis

没有基于AFL的模糊测试工具可用于真实设备。作为粗略估计，我们只测试了真实设备模糊测试的开销。我们假设设备上已经有某些机制可以为AFL收集路径覆盖信息，例如ETM [9]。
真实设备的模糊测试开销大致由三部分组成：测试用例生成、测试用例输入和程序执行。在这里，我们只估计了测试用例输入和程序执行的开销，因为所有方法的测试用例生成应该是相同的。我们使用pyOCD [39]控制NXP FRDM-K64F开发板并模拟输入过程。Python脚本将一个已知的测试用例写入板的保留内存区域1,000次。板上的程序在迭代完成后终止。传输1KB的测试用例时，每个测试用例传输大约需要0.23秒。我们还比较了与pararehosting、Zephyr QEMU和FRDM-K64F开发板相同工作负载的执行速度。我们发现FRDM-K64F开发板的执行速度比QEMU慢14倍，比pararehosting慢287倍。总之，真实设备上的模糊测试速度远低于我们的方法和基于仿真的方法。

### C. CVE Analysis
We have found 28 previously-unknown bugs as shown in Table IV. Five of them were confirmed by CVE. For the rest, we have reported them to the manufacturers or vendors and 19 of them have been confirmed at the time of writing.所有的这些错误都是内存错误。

### D. Identifying the Gap
由于存在架构上的差异，在MCU上的行为并不能在类UNIX系统上完全一比一复现。
具体而言，就是将rehosting环境下发现的错误放到真实环境中，看看是否仍然可以触发bug。实验发现bug仍然会触发，只不过不会严重到使得固件立刻崩溃。

这段话主要讨论了在嵌入式系统（特别是MCU设备）上进行模糊测试时，真实设备与模拟环境（如Linux机器）之间存在的错误可观察性差异。研究者们通过实验，尝试更好地理解这种差异，并探索了在真实MCU设备上复现通过pararehosting方法发现的错误的可行性。
研究者们创建了一个包含真实和人造错误的代码片段数据集，并在真实设备上测试了这些错误，以观察它们是否能够被触发。他们发现，尽管在模拟环境中大多数错误可以通过ASAN立即观察到，但在真实设备上，这些错误往往不容易被观察到。文章接着详细讨论了几个具体的错误类型，包括除以零、栈溢出和空指针解引用，并解释了为什么这些错误在真实设备上可能不会立即导致崩溃。
1. **除以零**：在ARM处理器上，默认情况下除以零不会导致崩溃，但可以通过设置特定的寄存器来启用除以零检测。
2. **栈溢出**：在模拟环境中，栈溢出可以被ASAN容易地检测到。在真实设备上，默认配置下固件可能继续执行，但可以通过配置栈溢出检测来缓解这个问题。
3. **空指针解引用**：在模拟环境中，访问零地址的内存总是会导致段错误。但在ARM Cortex-M MCU设备上，从零地址读取是允许的，而写入会导致硬错误。
最后，研究者们指出，由于架构差异，重新托管固件上的漏洞利用证明（PoE）可能不适用于真实设备，而且真实设备上的固件错误可能不会立即导致崩溃，这对于在真实设备上进行错误狩猎带来了挑战。研究者们强调了在固件分析中使用内存检查器的重要性，并指出了在真实设备上复现模糊测试结果的复杂性。


## 和其他工作进行对比

在图4中，我们从不同维度比较了我们的方法（部分重新托管）与现有工作。请注意，到目前为止，还不存在可以精确仿真任意MCU设备的完美完整仿真解决方案。
在性能方面，即使是高端MCU也以较低的频率运行。因此，设备上的测试可能效率较低。此外，真实设备上的并行性有限。要增加一个被测试系统（SUT），必须集成一个新的真实设备，并与其他设备正确协调。对于外设转发，设备的频繁重启和信号转发都是耗时的。基于仿真的方法（包括半重新托管）可以在主机上同时运行多个SUT，但指令翻译会带来不可避免的开销。我们的方法允许在主机上进行本地测试，充分利用了现代硬件的并行性和高性能。
关于软件可测试性，我们指的是观察SUT行为的能力。例如，能够观察到崩溃对于模糊测试至关重要。另一个例子是，收集运行时执行路径可以通过生成高质量的测试用例来辅助模糊测试。为了提高可测试性，通常使用工具。工具允许收集更丰富的上下文信息。在模糊测试中，像ASAN [50]这样的工具可以显著提高崩溃识别能力。在真实设备上，除非有非侵入式的硬件调试功能，如ETM [9]，否则几乎不可能收集固件执行信息。
外设转发、完整仿真和半重新托管都依赖于像QEMU这样的仿真器。有了间接层，可测试性可以大大提高。然而，它仍然无法与本地重新托管相比。具体来说，在实践中，基于仿真的方法只能在被仿真机器的上下文中提取信息，而本地重新托管则可以在程序本身的上下文中收集信息，例如，通过工具。在我们的评估（第VI-C节）中，我们已经展示了ASAN如何提高错误发现能力。除了一个（CVE-2019-17210）之外，我们使用工具识别的所有错误，如果未启用ASAN，这些错误就变得不可见。
在硬件独立性方面，设备上的分析和外设转发都需要真实设备，而部分重新托管和基于仿真的方法不依赖于任何真实设备。因此，它们更具可扩展性。
就代码覆盖率而言，所有方法都可以覆盖硬件独立的代码，这在图1中用红线圈出。然而，由于部分重新托管和半重新托管用本地实现替换了依赖硬件的代码，它们无法发现与低级硬件相关代码（例如，驱动程序）的问题，这在图1中用绿线圈出。

## CONCLUSIONS
MCU固件的内部安全测试对物联网安全至关重要。然而，由于测试环境的不同，MCU固件无法使用x86上的复杂工具。
将固件重新编译到本地x86主机可以直接解决这个问题。然而，特别定制的移植工作令人畏惧，容易出错，有时甚至是不可能的。因此，我们提出了pararehosting（部分重新托管）来简化这一过程。可移植的MCU能够模拟MCU的通用功能，而paraAPIs则方便了基于HAL（硬件抽象层）的外设函数替换，以处理外设。直接重新托管MCU操作系统可以解决现有解决方案面临的基本问题（性能、可扩展性和可见性）。我们已经实现了我们的想法，并重新托管了九个MCU操作系统。我们对Amazon FreeRTOS、ARM Mbed OS、Zephyr和LiteOS的库进行了安全测试。这些操作系统附带的大多数库可以通过现成的动态分析工具进行测试，包括AFL和ASAN。我们的实验表明，真实固件中的错误可以在重新托管的固件中复现，并且错误在重新托管的固件中更易于观察。通过使用模糊测试运行我们的工具，已经发现了以前未知的错误。