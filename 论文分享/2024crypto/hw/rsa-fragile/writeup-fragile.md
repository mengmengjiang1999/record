# writeup-Fragile

完成人：陈张萌

### 解题思路

根据题目的以下代码：

```
        m = 2 ** 3
        ra_ = randint(1000,10000)
        p_ = pow(a,m) + ra_
        p = next_prime(p_)
        ra = p - p_ + ra_
        rb_ = randint(1000, 10000)
        q_ = pow(b, m) + rb_
        q = next_prime(q_)
        rb = q - q_ + rb_
```

可以发现p,ra,a,q,rb,b之间存在一定的关系：

$$
p=a^8+ra\\
q=b^8+rb
$$

ra_的作用是使得p不一定是大于$a^8$的第一个质数。
然后我们会发现：
$$
n=p*q=(a^8+ra)*(b^8+rb)
$$
再根据：

```
        if ra > 100000 or rb > 100000:
            continue
        if b > iroot(2 * pow(a, m) + ra, m)[0]:
            continue
        if ra > 2 * iroot(a,m//2)[0] or rb > 2 * iroot(b,m//2)[0]:
            continue
        break
```

这些约束关系，我们可以发现ra和rb都很小。这样的话，对n开8次跟号，取整数部分，发现这就是ab。因为$(a+1)^8b^8$和$a^8(b+1)^8$都小于n。

```
n = 28098722633030488893312283528887829649553659514053781575839443778746567710358683558509768930786261053897116586758341172713231425712608663734433267335002333760261583976848753337338129716792124202066388265994360580739266657504481707827816610267011366001142300093926601793983384666604377328323493638248481764153911921310476848622133065363121266256704484624454408157373499690818152144645904269865423396689289703578108901228755055729490144039004436875090060394642072739901593627031008002995026214521011417826487454434739123729500727953687489123493596702814564384266479646307886530097993679086392267067430262508230063492593
n_r8=gmpy2.iroot(n,m)[0]
```

发现n开8次跟号后很小，已经可以直接进行质因数分解了。分解结果：

```
nbs=[2,2,2,7,17,17,23,144680046702678787996517557250872603,2112824752321302638932489226261448911]
```

然后观察题目中的约束条件，发现a和b都是128位，p和q都是1024位，而且a<b<2a。因此，对上面的质因数进行排列组合后，计算出符合约束条件的a和b，关键代码如下：

```python
for i in range(1<<6):
    a=144680046702678787996517557250872603
    b=2112824752321302638932489226261448911
    cnt=i
    for j in range(7):
        if cnt&1:
            a*=nbs[j]
        else:
            b*=nbs[j]
        cnt=cnt>>1

    p=a**8+ra
    q=b**8+rb

    if a.bit_length()<=128 and b.bit_length()<=128:
        if p.bit_length()==1024 and q.bit_length()==1024:
            if a<b and b<a*2 or b<a and a<b*2:
                print(a,b)
```

得到只有一对满足条件的a和b：$$a=334500267976593357847948592364017458136\\
b=340164785123729724868130765428093274671$$

进而就可以直接计算得到p,q，进而得到n的分解。然后就可以求出phi和d，由密文算出明文。

### 操作内容

1. 计算n的8次方根
   
   ```python
   n = 28098722633030488893312283528887829649553659514053781575839443778746567710358683558509768930786261053897116586758341172713231425712608663734433267335002333760261583976848753337338129716792124202066388265994360580739266657504481707827816610267011366001142300093926601793983384666604377328323493638248481764153911921310476848622133065363121266256704484624454408157373499690818152144645904269865423396689289703578108901228755055729490144039004436875090060394642072739901593627031008002995026214521011417826487454434739123729500727953687489123493596702814564384266479646307886530097993679086392267067430262508230063492593
   n_r8=gmpy2.iroot(n,m)[0]
   ```

```
得到n_r8=113785211780087890729835403913740862621352579296072519073738292962853891673256

2. 在factordb.com上进行质因数分解
得到以下结果：
```

nbs=[2,2,2,7,17,17,23,144680046702678787996517557250872603,2112824752321302638932489226261448911]

```
3. 运行以下代码，得到符合条件的a和b

```python
for i in range(1<<6):
    a=144680046702678787996517557250872603
    b=2112824752321302638932489226261448911
    cnt=i
    for j in range(7):
        if cnt&1:
            a*=nbs[j]
        else:
            b*=nbs[j]
        cnt=cnt>>1

    p=a**8+ra
    q=b**8+rb
    if a.bit_length()<=128 and b.bit_length()<=128:
        if p.bit_length()==1024 and q.bit_length()==1024:
            if a<b and b<a*2 or b<a and a<b*2:
                print(a,b)
```

得到：$$a=334500267976593357847948592364017458136\\
b=340164785123729724868130765428093274671$$

4. 计算明文

```python
ct = 1361368491194202361715607865372797868849909740139730895054740999951755977992724940480130958163781061991384502597774968578284702191375825258332749459177999721414531960173967638050842294432428891589365478524879091438660354502169037756949918455465931069407443747905678846811248473459896942787043705093661155283970943862884656259675846526304020149516360300122739147864690004414833366319773397061007864065322841302908571648122903295064833926287970664637537668175501504866705196230324464962122113398544393881450146243000410853975781504185685414280739943390199620950135398253008721600717727922668728798959184802994979420495

phi=(p-1)*(q-1)

e = 0x10001

d=pow(e,-1,phi)

m=pow(ct,d,n)

print(long_to_bytes(m))
```

得到最终flag

### flag

最终得到flag为`flag{286c74e4-3b49-4863-9429-d4a1392d3aba}`


