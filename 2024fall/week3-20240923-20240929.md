# week3-20240923-20240929

afl++的插桩方案

matiec的编译器原理


应该只需要看stage4的new_code_generator部分，是根据ordered_tree_root翻译出来的


stage4out_c是一个class，
flush不知道干啥的。
enable_output和disable_output应该是控制是否可以输出

indent_right和left不知道什么情况

print就是直接把value的值输出了

printlocation_comasep不知道干啥的
总之stage4out_c就是字面意思，定义了一些用于输出的class

```c++
int stage4(symbol_c *tree_root, const char *builddir) {
  stage4out_c s4o;
  visitor_c *generate_code = new_code_generator(&s4o, builddir);

  if (NULL == generate_code) ERROR;

  tree_root->accept(*generate_code);
  //accept是虚函数，实际上最终调用的是generate_code.visor 在get_datatype_info文件里面
//   visitor也是一个设计模式的问题，实际上就是输出一下数据类型了


  delete_code_generator(generate_code);

  return 0;
}

// safewstring_type_name_c 指的就是BOOL，INT等等类型名称
// simple_type_declaration_c 等等语句是yy文件给出来的


```c++

关于visitor_c的分析：

可以认为每一个visitor_c对应一个抽象语法书的树上的结点。可能是叶子结点，也可能是非叶子结点。

visitor_c
fcall_visitor_c
search_visitor_c
null_visitor_c

visitor_c
iterator_visitor_c
fcall_iterator_visitor_c

有这些继承类型。然后如果是list这种非叶子结点就会继续递归。

逻辑我大概明白了，但是不知道怎么继续修改


```

```



20240924

编译原理-数据流分析，回去预习


20240929


1. 搞明白关于编译原理的数据流分析部分

2. fuzz流程先跑起来再说


明日todo：

fuzz流程跑起来


