# week9-20241104-20241110

本周进展：

周一

周二：

上午面试，下午日语课，然后睡觉，晚上研工组开会，然后摸鱼。

周三：
上午去中关村。

https://ch3nye.top/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/

阅读了污点分析技术笔记

https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.5_taint_analysis.html

CTF的污点分析笔记。

采用污点分析的方式对代码进行分析。

已知一个抽象语法树，希望应用污点分析技术


# Question

@workspace 这个项目主要完成了什么功能

# Answer

=====REFERENCES======

path: czm2025/matiec/readme<fitten@refcode>```


  MATIEC - IEC 61131-3 compiler


  The following compiler has been based on the
  FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)


  Copyright (C) 2003-2012  Mario de Sousa (msousa@fe.up.pt)


****************************************************************
****************************************************************
****************************************************************
*********                                              *********
*********                                              *********
*********         O V E R A L L    G O A L S           *********
*********                                              *********
*********                                              *********
****************************************************************
****************************************************************
****************************************************************



 This project has the goal of producing an open source compiler for the programming languages defined
in the IEC 61131-3 standard. These programming languages are mostly used in the industrial automation 
domain, to program PLCs (Programmable Logic Controllers).

 This standard defines 5 programming languages:
     - IL : Instructtion List
            A textual programming language, somewhat similar to assembly.
     - ST : Structured Text
            A textual programming language, somewhat similar to Pascal.
     - FBD: Function Block Diagram
            A graphical programming language, somewhat similar to an electrical circuit diagram based on small 
             scale integration ICs (Integrated Circuits) (counters, AND/OR/XOR/... logic gates, timers, ...).
     - LD : Ladder Diagram
            A graphical programming language, somewhat similar to an electrical circuit diagram based on 
             relays (used for basic cabled logic controllers).
     - SFC: Sequential Function Chart
            A graphical programming language, that defines a state machine, based largely on Grafcet.
            (may also be expressed in textual format).

 Of the above 5 languages, the standard defines textual representations for IL, ST and SFC. 
It is these 3 languages that we target, and we currently support all three, as long as they are
expressed in the textual format as defined in the standard.

 Currently the matiec project generates two compilers (more correctly, code translaters, but we like
to call them compilers :-O ): iec2c, and iec2iec

 Both compilers accept the same input: a text file with ST, IL and/or SFC code.

 The iec2c compiler generates ANSI C code which is equivalent to the IEC 61131-3 code expressed in the input file.

 The iec2iec compiler generates IEC61131-3 code which is equivalent to the IEC 61131-3 code expressed in the input file.
This last compiler should generate and output file which should be almost identical to the input file (some formating 
may change, as well as the case of letters, etc.). This 'compiler' is mostly used by the matiec project contributors
to help debug the lexical and syntax portions of the compilers.



 To compile/build these compilers, just
$./configure; make





****************************************************************
****************************************************************
****************************************************************
*********                                              *********
*********                                              *********
*********   O V E R A L L    A R C H I T E C T U R E   *********
*********                                              *********
*********                                              *********
****************************************************************
****************************************************************
****************************************************************

 The compiler works in 4(+1) stages:
 ==================================
 Stage 1    - Lexical analyser       - implemented with flex (stage1_2/iec_flex.ll)
 Stage 2    - Syntax parser          - implemented with bison (stage1_2/iec_bison.yy)
 Stage pre3 - Populate symbol tables - Symbol tables that will ease searching for symbols in the abstract symbol tree.
 Stage 3    - Semantics analyser     - currently does type checking only
 Stage 4    - Code generator         - generates ANSI C code

 Stage 5    - Binary code generator - gcc, javac, etc... (Not integrated into matiec compiler. Must be called explicitly by the user.)



 Data structures passed between stages, in global variables:
 ==========================================================
   1->2   : tokens (int), and token values (char *) (defined in stage1_2/stage1_2_priv.hh)
   2->1   : symbol tables (implemented in util/symtable.[hh|cc], and defined in stage1_2/stage1_2_priv.hh)
   2->3   : abstract syntax tree (tree of C++ objects, whose classes are defined in absyntax/absyntax.hh)
pre3->3,4 : global symbol tables (defined in util/[d]symtable.[hh|cc] and declared in absyntax_utils/absyntax_utils.hh)
   3->4   : abstract syntax tree (same as 2->3), but now annotated (i.e. some extra data inserted into the absyntax tree)

   4->5   : file with program in c, java, etc...




 The compiler works in several passes:
 ====================================

Stage 1 and Stage 2
-------------------
  Executed in one single pass. This pass will:
  - Do lexical analysis
  - Do syntax analysis
  - Execute the absyntax_utils/add_en_eno_param_decl_c visitor class
    This class will add the EN and ENO parameter declarations to all
    functions that do not have them already explicitly declared by the user.
    This will let us handle these parameters in the remaining compiler just as if
    they were standard input/output parameters.


Stage Pre3
----------
  Executed in one single pass. This pass will populate the following symbol tables:
   - function_symtable;            /* A symbol table with all globally declared functions POUs. */
   - function_block_type_symtable; /* A symbol table with all globally declared functions block POUs. */
   - program_type_symtable;        /* A symbol table with all globally declared program POUs. */
   - type_symtable;                /* A symbol table with all user declared (non elementary) datat type definitions. */
   - enumerated_value_symtable;    /* A symbol table with all identifiers (values) declared for enumerated types. */


Stage 3
-------
  Executes two algorithms (flow control analysis, and data type analysis) in several passes.

  Flow control:
     Pass 1: Does flow control analysis (for now only of IL code) 
             Implemented in -> stage3/flow_control_analysis_c
             This will anotate the abstract syntax tree 
             (Every object of the class il_instruction_c that is in the abstract syntax tree will have the variable 'prev_il_instruction' correctly filled in.)

  Data Type Analysis
     Pass 1: Analyses the possible data types each expression/literal/IL instruction/etc. may take 
             Implemented in -> stage3/fill_candidate_datatypes_c
             This will anotate the abstract syntax tree 
             (Every object of in the abstract syntax tree that may have a data type, will have the variable 'candidate_datatypes' correctly filled in.
             Additionally, objects in the abstract syntax tree that represen function invocations will have the variable 
              'candidate_functions' correctly filled in.)
Pass 2: Narrows all the possible data types each expression/literal/IL instruction/etc. may take down to a single data type 
             Implemented in -> stage3/narrow_candidate_datatypes_c
             This will anotate the abstract syntax tree 
             (Every object of in the abstract syntax tree that may have a data type, will have the variable 'datatype' correctly filled in.
              Additionally, objects in the abstract syntax tree that represen function invocations will have the variables 
              'called_function_declaration' and 'extensible_param_count' correctly filled in.
              Additionally, objects in the abstract syntax tree that represen function block (FB) invocations will have the variable
              'called_fb_declaration' correctly filled in.)
     Pass 2: Prints error messages in the event of the IEC 61131-3 source code being analysed contains semantic data type incompatibility errors.
             Implemented in -> stage3/print_datatype_errors_c

  
Stage 4
-------
  Has 2 possible implementations.
  
  iec2c  :  Generates C source code in a single pass (stage4/generate_c).
  iec2iec:  Generates IEC61131 source code in a single pass (stage4/generate_iec).






****************************************************************
****************************************************************
****************************************************************
*********                                              *********
*********                                              *********
*********               N O T E S                      *********
*********                                              *********
*********                                              *********
****************************************************************
****************************************************************
****************************************************************






 NOTE 1
 ======
 Note that stage 2 passes data back to stage 1. This is only
possible because both stages are executed in the same pass.



 NOTE 2
 ======
 It would be nice to get this parser integrated into the gcc
group of compilers. We would then be able to compile our st/il
programs directly into executable binaries, for all the processor
architectures gcc currently supports.
 The gcc compilers are divided into a frontend and backend. The
data structure between these two stages is called the syntax
tree. In essence, we would need to create a new frontend that
```<fitten@refcode>

path: czm2025/matiec/absyntax/absyntax.hh<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *  Copyright (C) 2003-2011  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2007-2011  Laurent Bessard and Edouard Tisserant
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/*
 * An IEC 61131-3 compiler.
 *
 * Based on the
 * FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)
 *
 */

/*
 * Declaration of the Abstract Syntax data structure components
 */

/*
 * ABSYNTAX.H
 *
 * This generates the parse tree structure used to bind the components
 * identified by Bison in the correct syntax order. At the end of the
 * Bison analysis the tree is walked in a sequential fashion generating
 * the relavent code.
 */

#ifndef _ABSYNTAX_HH
#define _ABSYNTAX_HH


#include <stdio.h> // required for NULL
#include <vector>
#include <map>
#include <string>
#include <stdint.h>  // required for uint64_t, etc...
#include "../main.hh" // required for uint8_t, real_64_t, ..., and the macros INT8_MAX, REAL32_MAX, ... */




/* Forward declaration of the visitor interface
 * declared in the visitor.hh file
 * We cannot include the visitor.hh file, as it will
 * include this same file first, as it too requires references
 * to the abstract syntax classes defined here.
 */
class visitor_c; // forward declaration


class symbol_c; // forward declaration







/* Case insensitive string compare */
  /* Case insensitive string compare copied from
   * "The C++ Programming Language" - 3rd Edition
   * by Bjarne Stroustrup, ISBN 0201889544.
   */
class nocasecmp_c {
    public:
      bool operator() (const std::string& x, const std::string& y) const {
        std::string::const_iterator ix = x.begin();
        std::string::const_iterator iy = y.begin();

        for(; (ix != x.end()) && (iy != y.end()) && (toupper(*ix) == toupper(*iy)); ++ix, ++iy);
        if (ix == x.end()) return (iy != y.end());
        if (iy == y.end()) return false;
        return (toupper(*ix) < toupper(*iy));
      };
  };



/*** constant folding ***/
/* During stage 3 (semantic analysis/checking) we will be doing constant folding.
 * That algorithm will anotate the abstract syntax tree with the result of operations
 * on literals (i.e. 44 + 55 will store the result 99).
 * Since the same source code (e.g. 1 + 0) may actually be a BOOL or an ANY_INT,
 * or an ANY_BIT, we need to handle all possibilities, and determine the result of the
 * operation assuming each type.
 * For this reason, we have one entry for each possible type, with some expressions
 * having more than one entry filled in!
 */    
class const_value_c {
  public:
    typedef enum { cs_undefined,   /* not defined/not yet evaluated --> const_value is not valid! */
                   cs_non_const,   /* we have determined that expression is not a const value --> const_value is not valid! */
                   cs_const_value, /* const value is valid */
                   cs_overflow     /* result produced overflow or underflow --> const_value is not valid! */
                 } const_status_t;
 
    template<typename value_type> class const_value__ {
      const_status_t status;  
      value_type     value;
      
      public:
      const_value__(void): status(cs_undefined), value(0) {};
      
      value_type get(void)              {return value;}
      void       set(value_type value_) {status = cs_const_value; value = value_;}
      void       set_overflow(void)     {status = cs_overflow   ;}
      void       set_nonconst(void)     {status = cs_non_const  ;}
      bool       is_valid    (void)     {return (status == cs_const_value);}
      bool       is_overflow (void)     {return (status == cs_overflow   );}
      bool       is_nonconst (void)     {return (status == cs_non_const  );}
      bool       is_undefined(void)     {return (status == cs_undefined  );}
      bool       is_zero     (void)     {return (is_valid() && (get() == 0));}

      /* comparison operator */
      bool operator==(const const_value__ cv) {
        return (    ((status!=cs_const_value) && (status==cv.status)) 
                 || ((status==cs_const_value) && (value ==cv.value )));
      }

    };

    const_value__< int64_t>  _int64; /* status is initialised to UNDEFINED */
    const_value__<uint64_t> _uint64; /* status is initialised to UNDEFINED */
    const_value__<real64_t> _real64; /* status is initialised to UNDEFINED */
    const_value__<bool    >   _bool; /* status is initialised to UNDEFINED */
    
    /* default constructor and destructor */
     const_value_c(void) {};
    ~const_value_c(void) {};
    
    /* comparison operator */
    bool operator==(const const_value_c cv)
      {return ((_int64==cv._int64) && (_uint64==cv._uint64) && (_real64==cv._real64) && (_bool==cv._bool));}                                                     
      
    /* return true if at least one of the const values (int, real, ...) is a valid const value */
    bool is_const(void) 
      {return (_int64.is_valid() || _uint64.is_valid() || _real64.is_valid() || _bool.is_valid());}   
};

// A forward declaration
class token_c;

/* The base class of all symbols */
class symbol_c {

  public:
    /* WARNING: only use this method for debugging purposes!! */
    virtual const char *absyntax_cname(void) {return "symbol_c";};

    /*
     * Annotations produced during stage 1_2
     */    
    /* Points to the parent symbol in the AST, i.e. the symbol in the AST that will contain the current symbol */
    symbol_c *parent;
    /* Some symbols may not be tokens, but may be clearly identified by a token.
     * For e.g., a FUNCTION declaration is not itself a token, but may be clearly identified by the
     * token_c object that contains it's name. Another example is an element in a STRUCT declaration,
     * where the structure_element_declaration_c is not itself a token, but can be clearly identified
     * by the structure_element_name
     * To make it easier to find these tokens from the top level object, we will have the stage1_2 populate this
     * token_c *token wherever it makes sense.
     * NOTE: This was a late addition to the AST. Not all objects may be currently so populated.
     *       If you need this please make sure the bison code is populating it correctly for your use case.
     */
    token_c  *token;
    
    /* Line number for the purposes of error checking.  */
    int first_line;
    int first_column;
    const char *first_file;  /* filename referenced by first line/column */
    long int first_order;    /* relative order in which it is read by lexcial analyser */
    int last_line;
    int last_column;
    const char *last_file;  /* filename referenced by last line/column */
    long int last_order;    /* relative order in which it is read by lexcial analyser */


    /*
     * Annotations produced during stage 3
     */    
    /*** Data type analysis ***/
    std::vector <symbol_c *> candidate_datatypes; /* All possible data types the expression/literal/etc. may take. Filled in stage3 by fill_candidate_datatypes_c class */
    /* Data type of the expression/literal/etc. Filled in stage3 by narrow_candidate_datatypes_c 
     * If set to NULL, it means it has not yet been evaluated.
     * If it points to an object of type invalid_type_name_c, it means it is invalid.
     * Otherwise, it points to an object of the apropriate data type (e.g. int_type_name_c, bool_type_name_c, ...)
     */
    symbol_c *datatype;
    /* The POU in which the symbolic variable (or structured variable, or array variable, or located variable, - any more?)
     * was declared. This will point to a Configuration, Resource, Program, FB, or Function.
     * This is set in stage 3 by the datatype analyser algorithm (fill/narrow) for the symbols:
     *  symbolic_variable_c, array_variable_c, structured_variable_c
     */
    symbol_c *scope;    

    /*** constant folding ***/
    /* If the symbol has a constant numerical value, this will be set to that value by constant_folding_c */
    const_value_c const_value;
    
    /*** Enumeration datatype checking ***/    
    /* Not all symbols will contain the following anotations, which is why they are not declared here in symbol_c
     * They will be declared only inside the symbols that require them (have a look at absyntax.def)
     */
    typedef std::multimap<std::string, symbol_c *, nocasecmp_c> enumvalue_symtable_t;
    
    /*
     * Annotations produced during stage 4
     */
    /* Since we support several distinct stage_4 implementations, having explicit entries for each
     * possible use would quickly get out of hand.
     * We therefore simply add a map, that each stage 4 may use for all its needs.
     */
    typedef std::map<std::string, symbol_c *> anotations_map_t;
    anotations_map_t anotations_map;
    

  public:
    /* default constructor */
    symbol_c(int fl = 0, int fc = 0, const char *ffile = NULL /* filename */, long int forder=0, /* order in which it is read by lexcial analyser */
             int ll = 0, int lc = 0, const char *lfile = NULL /* filename */, long int lorder=0  /* order in which it is read by lexcial analyser */
            );

    /* default destructor */
    /* must be virtual so compiler does not complain... */ 
```<fitten@refcode>

path: czm2025/matiec/stage3/fill_candidate_datatypes.cc<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *
 *  Copyright (C) 2009-2012  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2012       Manuele Conti (manuele.conti@sirius-es.it)
 *  Copyright (C) 2012       Matteo Facchinetti (matteo.facchinetti@sirius-es.it)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/*
 * An IEC 61131-3 compiler.
 *
 * Based on the
 * FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)
 *
 */


/* TODO - things yet not checked by this data type checker...
 *
 * - check variable declarations
 * - check data type declarations
 * - check inside configurations (variable declarations)
 * - check SFC code
 * - must fix S and R IL functions (includes potientialy fixing stage4 code!) 
 */


/* NOTE: The algorithm implemented here assumes that flow control analysis has already been completed!
 *       BEFORE running this visitor, be sure to CALL the flow_control_analysis_c visitor!
 */


/*
 *  Fill the candidate datatype list for all symbols that may legally 'have' a data type (e.g. variables, literals, function calls, expressions, etc.)
 * 
 *  The candidate datatype list will be filled with a list of all the data types that expression may legally take.
 *  For example, the very simple literal '0' (as in foo := 0), may represent a:
 *    BOOL, BYTE, WORD, DWORD, LWORD, USINT, SINT, UINT, INT, UDINT, DINT, ULINT, LINT (as well as the SAFE versions of these data tyes too!)
 *
 * WARNING: This visitor class starts off by building a map of all enumeration constants that are defined in the source code (i.e. a library_c symbol),
 *          and this map is later used to determine the datatpe of each use of an enumeration constant. By implication, the fill_candidate_datatypes_c 
 *          visitor class will only work corretly if it is asked to visit a symbol of class library_c!!
 */

#include <../main.hh>         /* required for UINT64_MAX, INT64_MAX, INT64_MIN, ... */
#include "fill_candidate_datatypes.hh"
#include "datatype_functions.hh"
#include <typeinfo>
#include <list>
#include <string>
#include <string.h>
#include <strings.h>


#define GET_CVALUE(dtype, symbol)             ((symbol)->const_value._##dtype.get())
#define VALID_CVALUE(dtype, symbol)           ((symbol)->const_value._##dtype.is_valid())
#define IS_OVERFLOW(dtype, symbol)            ((symbol)->const_value._##dtype.is_overflow())


/* set to 1 to see debug info during execution */
static int debug = 0;



/*****************************************************/
/*                                                   */
/*  A small helper class...                          */
/*                                                   */
/*****************************************************/

/* Add to the global_enumerated_value_symtable the global enum value constants, i.e. the enum constants used in the enumerated
 * datatypes that are defined inside a TYPE ... END_TYPE declaration.
 */
/* NOTE: we do not store any NULL values in this symbol table, so we can safely use NULL and the null value. */

typedef dsymtable_c<symbol_c *> enumerated_value_symtable_t;
static enumerated_value_symtable_t global_enumerated_value_symtable;
 
 
class populate_globalenumvalue_symtable_c: public iterator_visitor_c {
  private:
    symbol_c *current_enumerated_type;

  public:
     populate_globalenumvalue_symtable_c(void) {current_enumerated_type = NULL;};
    ~populate_globalenumvalue_symtable_c(void) {}

  public:
  /*************************/
  /* B.1 - Common elements */
  /*************************/
  /**********************/
  /* B.1.3 - Data types */
  /**********************/
  /********************************/
  /* B 1.3.3 - Derived data types */
  /********************************/
  /*  enumerated_type_name ':' enumerated_spec_init */
  void *visit(enumerated_type_declaration_c *symbol) {
  //current_enumerated_type = symbol->enumerated_type_name;
    current_enumerated_type = symbol;
    symbol->enumerated_spec_init->accept(*this);
    current_enumerated_type = NULL;
    return NULL;
  }

  /* enumerated_specification ASSIGN enumerated_value */
  void *visit(enumerated_spec_init_c *symbol) {
    return symbol->enumerated_specification->accept(*this);
  }

  /* [enumerated_type_name '#'] identifier */
  void *visit(enumerated_value_c *symbol) {
    if (current_enumerated_type == NULL) ERROR;
    if (symbol->type != NULL) ERROR;

    enumerated_value_symtable_t::iterator lower = global_enumerated_value_symtable.lower_bound(symbol->value);
    enumerated_value_symtable_t::iterator upper = global_enumerated_value_symtable.upper_bound(symbol->value);
    for (; lower != upper; lower++)
      if (lower->second == current_enumerated_type) {
        /*  The same identifier is used more than once as an enumerated value/constant inside the same enumerated datat type! */
        return NULL; /* No need to insert it! It is already in the table! */
      }

    global_enumerated_value_symtable.insert(symbol->value, current_enumerated_type);
    return NULL;
  }

  /**************************************/
  /* B.1.5 - Program organization units */
  /**************************************/
  /* B 1.5.1 - Functions */
  void *visit(function_declaration_c *symbol) {return NULL;}
  /* B 1.5.2 - Function Blocks */
  void *visit(function_block_declaration_c *symbol) {return NULL;}
  /* B 1.5.3 - Programs */
  void *visit(program_declaration_c *symbol) {return NULL;}
  
}; /* populate_globalenumvalue_symtable_c */

static populate_globalenumvalue_symtable_c populate_globalenumvalue_symtable;


/*****************************************************/
/*                                                   */
/*  A small helper class...                          */
/*                                                   */
/*****************************************************/

/* Add to the local_enumerated_value_symtable the local enum value constants */
/* Notes:
 * Some enumerations are 
 *   (A) declared anonymously inside a VAR ... END_VAR declaration
 *       (e.g. VAR enum_var : (enumvalue1, enumvalue2); END_VAR)
 *  while others are 
 *   (B) declared (with a name) inside a TYPE .. END_TYPE declaration.
 *
 *  Values in (A) are added to the enumerated_value_symtable in absyntaxt_utils.cc.
 *  Values in (B) are only in scope inside the POU with the VAR END_VAR declaration.
 *
 * This class will add the enum values in (B) to the local_enumerated_value_symtable.
 *
 * If a locally defined enum value is identical to another locally defined enum_value, a 
 *  duplicate entry is created.
 *  However, if a locally defined enum value is identical to another globally defined enum_value, the
 *  corresponding entry in local_enumerated_value_symtable is also set to the local datatype.
 *  This is because anonynous locally feined enum datatypes are anonymous, and its enum values cannot therefore
 *  be disambiguated using EnumType#enum_value (since the enum type does not have a name, it is anonymous!).
 *  For this reason we implement the semantics where locally defined enum values, when in scope, will 'cover'
 *  the globally defined enum value with the same name/identifier.
 *  For example:
 *
 *  TYPE  GlobalEnumT: (xxx1, xxx2, xxx3) END_TYPE
 * 
 *   FUNCTION_BLOCK FOO
 *    VAR_INPUT
 *       GlobalEnumVar: GlobalEnumT;
 *      LocalEnumVar : (xxx1, yyy2, yyy3);
 *     END_VAR
 *     LocalEnumVar  := xxx1;   <-- We consider it OK!!!     xxx1 will reference the anonymous type used for LocalEnumVar
 *     GlobalEnumVar := xxx1;   <-- We consider it an error. xxx1 will reference the anonymous type used for LocalEnumVar
 *     GlobalEnumVar := GlobalEnumT#xxx1;
 *     END_FUNCTION_BLOCK
 */
 
static enumerated_value_symtable_t local_enumerated_value_symtable;


class populate_localenumvalue_symtable_c: public iterator_visitor_c {
  private:
    symbol_c *current_enumerated_type;

  public:
     populate_localenumvalue_symtable_c(void) {current_enumerated_type = NULL;};
    ~populate_localenumvalue_symtable_c(void) {}

  public:
  /*************************/
  /* B.1 - Common elements */
  /*************************/
  /**********************/
  /* B.1.3 - Data types */
  /**********************/
  /********************************/
  /* B 1.3.3 - Derived data types */
  /********************************/
  /*  TYPE type_declaration_list END_TYPE */
  void *visit(data_type_declaration_c *symbol) {return NULL;} // do not visit the type declarations!!
  
  /* enumerated_specification ASSIGN enumerated_value */
  void *visit(enumerated_spec_init_c *symbol) {
    current_enumerated_type = symbol;
    symbol->enumerated_specification->accept(*this);
    /* DO NOT visit the symbol->enumerated_value   !!! */
    current_enumerated_type = NULL;
    return NULL;
  }

  /* [enumerated_type_name '#'] identifier */
  void *visit(enumerated_value_c *symbol) {
    /* if the enumerated_value_c is not inside a enumerated_spec_init_c (e.g. used as the inital value of a variable), we simply return */
    if (current_enumerated_type == NULL) return NULL;  
    /* this is really an ERROR! The initial value may use the syntax NUM_TYPE#enum_value, but in that case we should have return'd in the above statement !! */
```<fitten@refcode>

path: czm2025/matiec/stage3/fill_candidate_datatypes.hh<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *
 *  Copyright (C) 2009-2012  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2012       Manuele Conti (manuele.conti@sirius-es.it)
 *  Copyright (C) 2012       Matteo Facchinetti (matteo.facchinetti@sirius-es.it)
 *
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/*
 * An IEC 61131-3 compiler.
 *
 * Based on the
 * FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)
 *
 */

/* NOTE: The algorithm implemented here assumes that flow control analysis has already been completed!
 *       BEFORE running this visitor, be sure to CALL the flow_control_analysis_c visitor!
 */


/*
 *  Fill the candidate datatype list for all symbols that may legally 'have' a data type (e.g. variables, literals, function calls, expressions, etc.)
 * 
 *  The candidate datatype list will be filled with a list of all the data types that expression may legally take.
 *  For example, the very simple literal '0' (as in foo := 0), may represent a:
 *    BOOL, BYTE, WORD, DWORD, LWORD, USINT, SINT, UINT, INT, UDINT, DINT, ULINT, LINT (as well as the SAFE versions of these data tyes too!)
 *
 * WARNING: This visitor class starts off by building a map of all enumeration constants that are defined in the source code (i.e. a library_c symbol),
 *          and this map is later used to determine the datatpe of each use of an enumeration constant. By implication, the fill_candidate_datatypes_c 
 *          visitor class will only work corretly if it is asked to visit a symbol of class library_c!!
 */


#include "../absyntax_utils/absyntax_utils.hh"
#include "datatype_functions.hh"

class fill_candidate_datatypes_c: public iterator_visitor_c {

  private:
    search_var_instance_decl_c *search_var_instance_decl;
    /* When calling a function block, we must first find it's type,
     * by searching through the declarations of the variables currently
     * in scope.
     * This class does just that...
     * A new object instance is instantiated whenever we start checking semantics
     * for a function block type declaration, or a program declaration.
     * This object instance will then later be called while the
     * function block's or the program's body is being handled.
     *
     * Note that functions cannot contain calls to function blocks,
     * so we do not create an object instance when handling
     * a function declaration.
     */
    //     search_var_instance_decl_c *search_var_instance_decl;

    /* This variable was created to pass information from
     * fill_candidate_datatypes_c::visit(enumerated_spec_init_c *symbol) function to
     * fill_candidate_datatypes_c::visit(enumerated_value_list_c *symbol) function.
     */
    symbol_c *current_enumerated_spec_type;
    
    /* pointer to the Function, FB, or Program currently being analysed */
    symbol_c *current_scope;
    /* Pointer to the previous IL instruction, which contains the current data type (actually, the list of candidate data types) of the data stored in the IL stack, i.e. the default variable, a.k.a. accumulator */
    symbol_c *prev_il_instruction;
    /* the current IL operand being analyzed */
    symbol_c *il_operand;
    symbol_c *widening_conversion(symbol_c *left_type, symbol_c *right_type, const struct widen_entry widen_table[]);

    /* Match a function declaration with a function call through their parameters.*/
    /* returns true if compatible function/FB invocation, otherwise returns false */
    bool  match_nonformal_call(symbol_c *f_call, symbol_c *f_decl);
    bool  match_formal_call   (symbol_c *f_call, symbol_c *f_decl, symbol_c **first_param_datatype = NULL);
    void  handle_function_call(symbol_c *fcall, generic_function_call_t fcall_data);
    void *handle_implicit_il_fb_call(symbol_c *il_instruction, const char *param_name,   symbol_c *&called_fb_declaration);
    void *handle_S_and_R_operator   (symbol_c *symbol,         const char *operator_str, symbol_c *&called_fb_declaration);
    void *handle_equality_comparison(const struct widen_entry widen_table[], symbol_c *symbol, symbol_c *l_expr, symbol_c *r_expr);
    void *handle_binary_expression  (const struct widen_entry widen_table[], symbol_c *symbol, symbol_c *l_expr, symbol_c *r_expr);
    void *handle_binary_operator    (const struct widen_entry widen_table[], symbol_c *symbol, symbol_c *l_expr, symbol_c *r_expr);
    void *handle_conditional_il_flow_control_operator   (symbol_c *symbol);
    void *fill_type_decl            (symbol_c *symbol,   symbol_c *type_name, symbol_c *spec_init);
    void *fill_spec_init            (symbol_c *symbol,   symbol_c *type_spec, symbol_c *init_value);
    void *fill_var_declaration      (symbol_c *var_list, symbol_c *type);

    /* a helper function... */
    symbol_c *base_type(symbol_c *symbol);    
    
    /* add a data type to a candidate data type list, while guaranteeing no duplicate entries! */
    /* Returns true if it really did add the datatype to the list, or false if it was already present in the list! */
    bool add_datatype_to_candidate_list  (symbol_c *symbol, symbol_c *datatype);
    bool add_2datatypes_to_candidate_list(symbol_c *symbol, symbol_c *datatype1, symbol_c *datatype2);
    void remove_incompatible_datatypes(symbol_c *symbol);
    
    
  public:
    fill_candidate_datatypes_c(symbol_c *ignore);
    virtual ~fill_candidate_datatypes_c(void);

    
    /***************************/
    /* B 0 - Programming Model */
    /***************************/
    void *visit(library_c *symbol);

    /*************************/
    /* B.1 - Common elements */
    /*************************/
    /*******************************************/
    /* B 1.1 - Letters, digits and identifiers */
    /*******************************************/
//  void *visit(                 identifier_c *symbol);
    void *visit(derived_datatype_identifier_c *symbol);
//  void *visit(         poutype_identifier_c *symbol);

    /*********************/
    /* B 1.2 - Constants */
    /*********************/
    /*********************************/
    /* B 1.2.XX - Reference Literals */
    /*********************************/
    /* defined in IEC 61131-3 v3 - Basically the 'NULL' keyword! */
    void *visit(ref_value_null_literal_c *symbol);
      
    /******************************/
    /* B 1.2.1 - Numeric Literals */
    /******************************/
    void *handle_any_integer(symbol_c *symbol);
    void *handle_any_real   (symbol_c *symbol);
    void *handle_any_literal(symbol_c *symbol, symbol_c *symbol_value, symbol_c *symbol_type);
    
    void *visit(real_c *symbol);
    void *visit(integer_c *symbol);
    void *visit(neg_real_c *symbol);
    void *visit(neg_integer_c *symbol);
    void *visit(binary_integer_c *symbol);
    void *visit(octal_integer_c *symbol);
    void *visit(hex_integer_c *symbol);
    void *visit(integer_literal_c *symbol);
    void *visit(real_literal_c *symbol);
    void *visit(bit_string_literal_c *symbol);
    void *visit(boolean_literal_c *symbol);
    void *visit(boolean_true_c *symbol);
    void *visit(boolean_false_c *symbol);

    /*******************************/
    /* B.1.2.2   Character Strings */
    /*******************************/
    void *visit(double_byte_character_string_c *symbol);
    void *visit(single_byte_character_string_c *symbol);

    /***************************/
    /* B 1.2.3 - Time Literals */
    /***************************/
    /************************/
    /* B 1.2.3.1 - Duration */
    /************************/
    void *visit(duration_c *symbol);

    /************************************/
    /* B 1.2.3.2 - Time of day and Date */
    /************************************/
    void *visit(time_of_day_c *symbol);
    void *visit(date_c *symbol);
    void *visit(date_and_time_c *symbol);


    /**********************/
    /* B 1.3 - Data types */
    /**********************/
    /********************************/
    /* B 1.3.3 - Derived data types */
    /********************************/
//  void *visit(data_type_declaration_c *symbol);   /* Not required. already handled by iterator_visitor_c base class */
//  void *visit(type_declaration_list_c *symbol);   /* Not required. already handled by iterator_visitor_c base class */
    void *visit(simple_type_declaration_c *symbol);
    void *visit(simple_spec_init_c *symbol);
    void *visit(subrange_type_declaration_c *symbol);
    void *visit(subrange_spec_init_c *symbol);
//  void *visit(subrange_specification_c *symbol);
    void *visit(subrange_c *symbol);
    void *visit(enumerated_type_declaration_c *symbol);
    void *visit(enumerated_spec_init_c *symbol);
    void *visit(enumerated_value_list_c *symbol);
    void *visit(enumerated_value_c *symbol);
    void *visit(array_type_declaration_c *symbol);
    void *visit(array_spec_init_c *symbol);
//  void *visit(array_specification_c *symbol);     /* Not required. already handled by iterator_visitor_c base class */
//  void *visit(array_subrange_list_c *symbol);
//  void *visit(array_initial_elements_list_c *symbol);
//  void *visit(array_initial_elements_c *symbol);
    void *visit(structure_type_declaration_c *symbol);
    void *visit(initialized_structure_c *symbol);
```<fitten@refcode>

path: czm2025/matiec/stage3/stage3.cc<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *
 *  Copyright (C) 2009-2012  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2007-2011  Laurent Bessard and Edouard Tisserant
 *  Copyright (C) 2012       Manuele Conti (manuele.conti@sirius-es.it)
 *  Copyright (C) 2012       Matteo Facchinetti (matteo.facchinetti@sirius-es.it)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/*
 * An IEC 61131-3 compiler.
 *
 * Based on the
 * FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)
 *
 */

#include "stage3.hh"

#include "flow_control_analysis.hh"
#include "fill_candidate_datatypes.hh"
#include "narrow_candidate_datatypes.hh"
#include "forced_narrow_candidate_datatypes.hh"
#include "print_datatypes_error.hh"
#include "lvalue_check.hh"
#include "array_range_check.hh"
#include "case_elements_check.hh"
#include "constant_folding.hh"
#include "declaration_check.hh"
#include "enum_declaration_check.hh"
#include "remove_forward_dependencies.hh"



static int enum_declaration_check(symbol_c *tree_root){
    enum_declaration_check_c enum_declaration_check(NULL);
    tree_root->accept(enum_declaration_check);
    return enum_declaration_check.get_error_count();
}


/* In order to correctly handle variable sized arrays
 * declaration_safety() must only be run after constant folding!
 *   NOTE that the dependency does not resides directly in declaration_check_c,
 *        but rather indirectly in the call to get_datatype_info_c::is_type_equal()
 *        which may in turn call get_datatype_info_c::is_arraytype_equal_relaxed()
 *
 * Example of a variable sized array:
 *   VAR_EXTERN CONSTANT max: INT; END_VAR;
 *   VAR_EXTERN xx: ARRAY [1..max] OF INT; END_VAR;
 */
static int declaration_safety(symbol_c *tree_root){
    declaration_check_c declaration_check(tree_root);
    tree_root->accept(declaration_check);
    return declaration_check.get_error_count();
}

static int flow_control_analysis(symbol_c *tree_root){
    flow_control_analysis_c flow_control_analysis(tree_root);
    tree_root->accept(flow_control_analysis);
    return 0;
}


/* Constant folding assumes that flow control analysis has been completed!
 * so be sure to call flow_control_analysis() before calling this function!
 */
static int constant_propagation(symbol_c *tree_root){
    constant_propagation_c constant_propagation(tree_root);
    tree_root->accept(constant_propagation);
    return constant_propagation.get_error_count();
}


/* Type safety analysis assumes that 
 *    - flow control analysis 
 *    - constant folding (constant check)
 * has already been completed, so be sure to call those semantic checkers
 * before calling this function
 */
static int type_safety(symbol_c *tree_root){
	fill_candidate_datatypes_c fill_candidate_datatypes(tree_root);
	tree_root->accept(fill_candidate_datatypes);
	narrow_candidate_datatypes_c narrow_candidate_datatypes(tree_root);
	tree_root->accept(narrow_candidate_datatypes);
	print_datatypes_error_c print_datatypes_error(tree_root);
	tree_root->accept(print_datatypes_error);
	forced_narrow_candidate_datatypes_c forced_narrow_candidate_datatypes(tree_root);
	tree_root->accept(forced_narrow_candidate_datatypes);
	return print_datatypes_error.get_error_count();
}


/* Left value checking assumes that data type analysis has already been completed,
 * so be sure to call type_safety() before calling this function
 */
static int lvalue_check(symbol_c *tree_root){
	lvalue_check_c lvalue_check(tree_root);
	tree_root->accept(lvalue_check);
	return lvalue_check.get_error_count();
}

/* Array range check assumes that constant folding has been completed!
 * so be sure to call constant_folding() before calling this function!
 */
static int array_range_check(symbol_c *tree_root){
	array_range_check_c array_range_check(tree_root);
	tree_root->accept(array_range_check);
	return array_range_check.get_error_count();
}


/* Case options check assumes that constant folding has been completed!
 * so be sure to call constant_folding() before calling this function!
 */
static int case_elements_check(symbol_c *tree_root){
	case_elements_check_c case_elements_check(tree_root);
	tree_root->accept(case_elements_check);
	return case_elements_check.get_error_count();
}


/* Removing forward dependencies only makes sense when stage1_2 is run with the pre-parsing option.
 * This algorithm has no dependencies on other stage 3 algorithms.
 * Typically this is run last, just to show that the remaining algorithms also do not depend on the fact that 
 * the library_c (i.e. the source code) does not contain forward dependencies.
 */
static int remove_forward_dependencies(symbol_c *tree_root, symbol_c **ordered_tree_root) {
	if (NULL != ordered_tree_root)    *ordered_tree_root = tree_root; // by default, consider tree_root already ordered
	if (!runtime_options.pre_parsing)  return 0;                      // No re-ordering necessary, just return
	  
	/* We need to re-order the elements in the library, to fix any forward references! */
	remove_forward_dependencies_c remove_forward_dependencies;
	symbol_c *new_tree_root = remove_forward_dependencies.create_new_tree(tree_root);
	if (NULL ==     new_tree_root)   ERROR;
	if (NULL != ordered_tree_root)   *ordered_tree_root = new_tree_root;
	return remove_forward_dependencies.get_error_count();
}


int stage3(symbol_c *tree_root, symbol_c **ordered_tree_root) {
	int error_count = 0;
	error_count += enum_declaration_check(tree_root);
	error_count += flow_control_analysis(tree_root);
	error_count += constant_propagation(tree_root);
	error_count += declaration_safety(tree_root);
	error_count += type_safety(tree_root);
	error_count += lvalue_check(tree_root);
	error_count += array_range_check(tree_root);
	error_count += case_elements_check(tree_root);
	error_count += remove_forward_dependencies(tree_root, ordered_tree_root);
	
	if (error_count > 0) {
		fprintf(stderr, "%d error(s) found. Bailing out!\n", error_count); 
		return -1;
	}
	return 0;
}
```<fitten@refcode>

path: czm2025/matiec/config/INSTALL<fitten@refcode>```you can use the `configure' options `--x-includes=DIR' and
`--x-libraries=DIR' to specify their locations.

   Some packages offer the ability to configure how verbose the
execution of `make' will be.  For these packages, running `./configure
--enable-silent-rules' sets the default to minimal output, which can be
overridden with `make V=1'; while running `./configure
--disable-silent-rules' sets the default to verbose, which can be
overridden with `make V=0'.

Particular systems
==================

   On HP-UX, the default C compiler is not ANSI C compatible.  If GNU
CC is not installed, it is recommended to use the following options in
order to use an ANSI C compiler:

     ./configure CC="cc -Ae -D_XOPEN_SOURCE=500"

and if that doesn't work, install pre-built binaries of GCC for HP-UX.

   On OSF/1 a.k.a. Tru64, some versions of the default C compiler cannot
parse its `<wchar.h>' header file.  The option `-nodtk' can be used as
a workaround.  If GNU CC is not installed, it is therefore recommended
to try

     ./configure CC="cc"

and if that doesn't work, try

     ./configure CC="cc -nodtk"

   On Solaris, don't put `/usr/ucb' early in your `PATH'.  This
directory contains several dysfunctional programs; working variants of
these programs are available in `/usr/bin'.  So, if you need `/usr/ucb'
in your `PATH', put it _after_ `/usr/bin'.

   On Haiku, software installed for all users goes in `/boot/common',
not `/usr/local'.  It is recommended to use the following options:

     ./configure --prefix=/boot/common

Specifying the System Type
==========================

   There may be some features `configure' cannot figure out
automatically, but needs to determine by the type of machine the package
will run on.  Usually, assuming the package is built to be run on the
_same_ architectures, `configure' can figure that out, but if it prints
a message saying it cannot guess the machine type, give it the
`--build=TYPE' option.  TYPE can either be a short name for the system
type, such as `sun4', or a canonical name which has the form:

     CPU-COMPANY-SYSTEM

where SYSTEM can have one of these forms:

     OS
     KERNEL-OS

   See the file `config.sub' for the possible values of each field.  If
`config.sub' isn't included in this package, then this package doesn't
need to know the machine type.

   If you are _building_ compiler tools for cross-compiling, you should
use the option `--target=TYPE' to select the type of system they will
produce code for.

   If you want to _use_ a cross compiler, that generates code for a
platform different from the build platform, you should specify the
"host" platform (i.e., that on which the generated programs will
eventually be run) with `--host=TYPE'.

Sharing Defaults
================

   If you want to set default values for `configure' scripts to share,
you can create a site shell script called `config.site' that gives
default values for variables like `CC', `cache_file', and `prefix'.
`configure' looks for `PREFIX/share/config.site' if it exists, then
`PREFIX/etc/config.site' if it exists.  Or, you can set the
`CONFIG_SITE' environment variable to the location of the site script.
A warning: not all `configure' scripts look for a site script.

Defining Variables
==================

   Variables not defined in a site shell script can be set in the
environment passed to `configure'.  However, some packages may run
configure again during the build, and the customized values of these
variables may be lost.  In order to avoid this problem, you should set
them in the `configure' command line, using `VAR=value'.  For example:

     ./configure CC=/usr/local2/bin/gcc

causes the specified `gcc' to be used as the C compiler (unless it is
overridden in the site shell script).

Unfortunately, this technique does not work for `CONFIG_SHELL' due to
an Autoconf bug.  Until the bug is fixed you can use this workaround:

     CONFIG_SHELL=/bin/bash /bin/bash ./configure CONFIG_SHELL=/bin/bash

`configure' Invocation
======================

   `configure' recognizes the following options to control how it
operates.

`--help'
`-h'
     Print a summary of all of the options to `configure', and exit.

`--help=short'
`--help=recursive'
     Print a summary of the options unique to this package's
     `configure', and exit.  The `short' variant lists options used
     only in the top level, while the `recursive' variant lists options
     also present in any nested packages.

`--version'
`-V'
     Print the version of Autoconf used to generate the `configure'
     script, and exit.

`--cache-file=FILE'
     Enable the cache: use and save the results of the tests in FILE,
     traditionally `config.cache'.  FILE defaults to `/dev/null' to
     disable caching.

`--config-cache'
`-C'
     Alias for `--cache-file=config.cache'.

`--quiet'
`--silent'
`-q'
     Do not print messages saying which checks are being made.  To
     suppress all normal output, redirect it to `/dev/null' (any error
     messages will still be shown).

`--srcdir=DIR'
     Look for the package's source code in directory DIR.  Usually
     `configure' can determine that directory automatically.

`--prefix=DIR'
     Use DIR as the installation prefix.  *note Installation Names::
     for more details, including other options available for fine-tuning
     the installation locations.

`--no-create'
`-n'
     Run the configure checks, but stop before creating any output
     files.

`configure' also accepts some other, not widely useful, options.  Run
`configure --help' for more details.

```<fitten@refcode>

path: czm2025/matiec/COPYING<fitten@refcode>```keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
```<fitten@refcode>

path: czm2025/matiec/absyntax/visitor.hh<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *  Copyright (C) 2003-2011  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2007-2011  Laurent Bessard and Edouard Tisserant
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/*
 * An IEC 61131-3 compiler.
 *
 * Based on the
 * FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)
 *
 */


/*
 * VISITOR.HH
 *
 *
 * The asbract syntax tree is scaned several times
 * during the whole compilation process. For e.g., stage 3 verifies
 * semantics, and stage 4 produces output.
 *
 * Since the number of functions that need to scan through
 * the abtract syntax tree may increase in time, (e.g. new
 * output formats, new semantic checks, etc...) while the
 * abstract syntax tree class structure is pretty stable
 * (i.e. the ST and IL languages will not be changing much...),
 * we use the 'visitor' design patern.
 *
 * It is not strictly necessary to use this pattern, but it does
 * have the advantage of bringing together the functions
 * that implement the same algorithm, each on a different
 * class of object in the abstract syntax tree.
 *
 *
 * This file contains the interface that each visitor class
 * must implement in order to be able to visit the abstract
 * syntax tree (class visitor_c)
 *
 * Three implementations of this interface are also provided,
 * that may be later extended to execute a particular algorithm.
 *
 * The null (class null_visitor_c) does nothing.
 *
 * The iterator (class iterator_visitor_c) iterates through
 * every object in the syntax tree.
 *
 * The search class (class search_visitor_c) iterates through
 * every object, until one returns a value != NULL.
 */


#ifndef _VISITOR_HH
#define _VISITOR_HH




#include "absyntax.hh"



#define SYM_LIST(class_name_c, ...)                                             virtual void *visit(class_name_c *symbol) = 0;
#define SYM_TOKEN(class_name_c, ...)                                            virtual void *visit(class_name_c *symbol) = 0;
#define SYM_REF0(class_name_c, ...)                                             virtual void *visit(class_name_c *symbol) = 0;
#define SYM_REF1(class_name_c, ref1, ...)                                       virtual void *visit(class_name_c *symbol) = 0;
#define SYM_REF2(class_name_c, ref1, ref2, ...)                                 virtual void *visit(class_name_c *symbol) = 0;
#define SYM_REF3(class_name_c, ref1, ref2, ref3, ...)                           virtual void *visit(class_name_c *symbol) = 0;
#define SYM_REF4(class_name_c, ref1, ref2, ref3, ref4, ...)                     virtual void *visit(class_name_c *symbol) = 0;
#define SYM_REF5(class_name_c, ref1, ref2, ref3, ref4, ref5, ...)               virtual void *visit(class_name_c *symbol) = 0;
#define SYM_REF6(class_name_c, ref1, ref2, ref3, ref4, ref5, ref6, ...)         virtual void *visit(class_name_c *symbol) = 0;

class visitor_c {
  public:
  #include "absyntax.def"

  virtual ~visitor_c(void);
};

#undef SYM_LIST
#undef SYM_TOKEN
#undef SYM_REF0
#undef SYM_REF1
#undef SYM_REF2
#undef SYM_REF3
#undef SYM_REF4
#undef SYM_REF5
#undef SYM_REF6






#define SYM_LIST(class_name_c, ...)                                             virtual void *visit(class_name_c *symbol);
#define SYM_TOKEN(class_name_c, ...)                                            virtual void *visit(class_name_c *symbol);
#define SYM_REF0(class_name_c, ...)                                             virtual void *visit(class_name_c *symbol);
#define SYM_REF1(class_name_c, ref1, ...)                                       virtual void *visit(class_name_c *symbol);
#define SYM_REF2(class_name_c, ref1, ref2, ...)                                 virtual void *visit(class_name_c *symbol);
#define SYM_REF3(class_name_c, ref1, ref2, ref3, ...)                           virtual void *visit(class_name_c *symbol);
#define SYM_REF4(class_name_c, ref1, ref2, ref3, ref4, ...)                     virtual void *visit(class_name_c *symbol);
#define SYM_REF5(class_name_c, ref1, ref2, ref3, ref4, ref5, ...)               virtual void *visit(class_name_c *symbol);
#define SYM_REF6(class_name_c, ref1, ref2, ref3, ref4, ref5, ref6, ...)         virtual void *visit(class_name_c *symbol);





class null_visitor_c: public visitor_c {
  public:
  #include "absyntax.def"

  virtual ~null_visitor_c(void);
};





class fcall_visitor_c: public visitor_c {
  public:
  virtual void fcall(symbol_c *symbol) = 0;

  public:
  #include "absyntax.def"

//   virtual ~fcall_visitor_c(void);
};




class iterator_visitor_c: public visitor_c {
  protected:
  void *visit_list(list_c *list);

  public:
  #include "absyntax.def"

  virtual ~iterator_visitor_c(void);
};





class fcall_iterator_visitor_c: public iterator_visitor_c {
  public:
  virtual void prefix_fcall(symbol_c *symbol);
  virtual void suffix_fcall(symbol_c *symbol);

  public:
  #include "absyntax.def"

  virtual ~fcall_iterator_visitor_c(void);
};





class search_visitor_c: public visitor_c {
  protected:
  void *visit_list(list_c *list);

  public:
  #include "absyntax.def"

  virtual ~search_visitor_c(void);
};


#undef SYM_LIST
#undef SYM_TOKEN
#undef SYM_REF0
#undef SYM_REF1
#undef SYM_REF2
#undef SYM_REF3
#undef SYM_REF4
#undef SYM_REF5
#undef SYM_REF6








#endif /*  _VISITOR_HH */
```<fitten@refcode>

path: czm2025/matiec/absyntax_utils/type_initial_value.cc<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *
 *  Copyright (C) 2003-2011  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2007-2011  Laurent Bessard and Edouard Tisserant
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/*
 * An IEC 61131-3 compiler.
 *
 * Based on the
 * FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)
 *
 */

/*
 * Determine the default initial value of a type declaration.
 *
 * This is part of the 4th stage that generates
 * a c++ source program equivalent to the IL and ST
 * code.
 */
/* Given a type definition declration, determine its default
 * initial value. Note that types based on other types
 * may have to iterate through each type it is based on
 * to determine the initial value.
 * E.g.
 *  TYPE
 *    A_t : INT := 10;
 *    B_t : A_t := 20;
 *    C_t : B_t;
 *    D_t : C_t := 40;
 *  END_TYPE
 * Where the default initial value for C_t is 20!
 */
/* NOTE: The main program only needs one instance of
 *       this class of object. This class
 *       is therefore a singleton.
 */


#include "absyntax_utils.hh"

//#define DEBUG
#ifdef DEBUG
#define TRACE(classname) printf("\n____%s____\n",classname);
#else
#define TRACE(classname)
#endif


type_initial_value_c *type_initial_value_c::instance(void) {
  if (_instance != NULL)
    return _instance;

  _instance = new type_initial_value_c;

  null_literal = new ref_value_null_literal_c();
  real_0       = new real_c("0");
  integer_0    = new integer_c("0");
  integer_1    = new integer_c("1");
  bool_0       = new boolean_literal_c(new bool_type_name_c(),new boolean_false_c());
  /* FIXME: Our current implementation only allows dates from 1970 onwards,
   * but the standard defines the date 0001-01-01 as the default value
   * for the DATE data type. Untill we fix our implementation, we use 1970-01-01
   * as our default value!!
   */
//date_literal_0 =  new date_literal_c(integer_1, integer_1, integer_1);
  date_literal_0    = new date_literal_c(new integer_c("1970"), integer_1, integer_1);
  daytime_literal_0 = new daytime_c(integer_0, integer_0, real_0);
  time_0       = new duration_c     (new time_type_name_c(), NULL, new interval_c(NULL, NULL, NULL, integer_0, NULL));  // T#0s
  date_0       = new date_c         (new date_type_name_c(), date_literal_0);  //  D#0001-01-01
  tod_0        = new time_of_day_c  (new  tod_type_name_c(), daytime_literal_0);  //  TOD#00:00:00
  dt_0         = new date_and_time_c(new   dt_type_name_c(), date_literal_0, daytime_literal_0);  //  DT#0001-01-01-00:00:00
  string_0     = new single_byte_character_string_c("''");
  wstring_0    = new double_byte_character_string_c("\"\"");

  return _instance;
}

type_initial_value_c::type_initial_value_c(void) {}



symbol_c *type_initial_value_c::get(symbol_c *type) {
  TRACE("type_initial_value_c::get(): called ");
  return (symbol_c *)type->accept(*type_initial_value_c::instance());
}




void *type_initial_value_c::handle_type_spec(symbol_c *base_type_name, symbol_c *type_spec_init) {
  if (type_spec_init != NULL)
     return type_spec_init;
  /* no initial value specified, so we return the initial value of the type this type is based on... */
  return base_type_name->accept(*this);
}


void *type_initial_value_c::handle_type_name(symbol_c *type_name) {
  /* look up the type declaration... */
  type_symtable_t::iterator iter = type_symtable.find(type_name);
    /* Type declaration not found!! */
    /* NOTE: Variables declared out of function block 'data types',for eg:  VAR  timer: TON; END_VAR
     * do not have a default value, so (TON) will never be found in the type symbol table. This means 
     * we cannot simply consider this an error and abort, but must rather return a NULL.
     */
  if (iter == type_symtable.end())   return NULL;

  return iter->second->accept(*this);  // iter->second is the type_decl
}

/* visitor for identifier_c should no longer be necessary. All references to derived datatypes are now stored in then          */
/* AST using either poutype_identifier_c or derived_datatype_identifier_c. In principe, the following should not be necesasry  */
void *type_initial_value_c::visit(                 identifier_c *symbol) {return handle_type_name(symbol);} /* should never occur */
void *type_initial_value_c::visit(         poutype_identifier_c *symbol) {return handle_type_name(symbol);} /* in practice it might never get called, as FB, Functions and Programs do not have initial value  */
void *type_initial_value_c::visit(derived_datatype_identifier_c *symbol) {return handle_type_name(symbol);}

/***********************************/
/* B 1.3.1 - Elementary Data Types */
/***********************************/
void *type_initial_value_c::visit(time_type_name_c *symbol)         {return (void *)time_0;}
void *type_initial_value_c::visit(bool_type_name_c *symbol)         {return (void *)bool_0;}
void *type_initial_value_c::visit(sint_type_name_c *symbol)         {return (void *)integer_0;}
void *type_initial_value_c::visit(int_type_name_c *symbol)          {return (void *)integer_0;}
void *type_initial_value_c::visit(dint_type_name_c *symbol)         {return (void *)integer_0;}
void *type_initial_value_c::visit(lint_type_name_c *symbol)         {return (void *)integer_0;}
void *type_initial_value_c::visit(usint_type_name_c *symbol)        {return (void *)integer_0;}
void *type_initial_value_c::visit(uint_type_name_c *symbol)         {return (void *)integer_0;}
void *type_initial_value_c::visit(udint_type_name_c *symbol)        {return (void *)integer_0;}
void *type_initial_value_c::visit(ulint_type_name_c *symbol)        {return (void *)integer_0;}
void *type_initial_value_c::visit(real_type_name_c *symbol)         {return (void *)real_0;}
void *type_initial_value_c::visit(lreal_type_name_c *symbol)        {return (void *)real_0;}
void *type_initial_value_c::visit(date_type_name_c *symbol)         {return (void *)date_0;}
void *type_initial_value_c::visit(tod_type_name_c *symbol)          {return (void *)tod_0;}
void *type_initial_value_c::visit(dt_type_name_c *symbol)           {return (void *)dt_0;}
void *type_initial_value_c::visit(byte_type_name_c *symbol)         {return (void *)integer_0;}
void *type_initial_value_c::visit(word_type_name_c *symbol)         {return (void *)integer_0;}
void *type_initial_value_c::visit(dword_type_name_c *symbol)        {return (void *)integer_0;}
void *type_initial_value_c::visit(lword_type_name_c *symbol)        {return (void *)integer_0;}
void *type_initial_value_c::visit(string_type_name_c *symbol)       {return (void *)string_0;}
void *type_initial_value_c::visit(wstring_type_name_c *symbol)      {return (void *)wstring_0;}

void *type_initial_value_c::visit(safetime_type_name_c *symbol)     {return (void *)time_0;}
void *type_initial_value_c::visit(safebool_type_name_c *symbol)     {return (void *)bool_0;}
void *type_initial_value_c::visit(safesint_type_name_c *symbol)     {return (void *)integer_0;}
void *type_initial_value_c::visit(safeint_type_name_c *symbol)      {return (void *)integer_0;}
void *type_initial_value_c::visit(safedint_type_name_c *symbol)     {return (void *)integer_0;}
void *type_initial_value_c::visit(safelint_type_name_c *symbol)     {return (void *)integer_0;}
void *type_initial_value_c::visit(safeusint_type_name_c *symbol)    {return (void *)integer_0;}
void *type_initial_value_c::visit(safeuint_type_name_c *symbol)     {return (void *)integer_0;}
void *type_initial_value_c::visit(safeudint_type_name_c *symbol)    {return (void *)integer_0;}
void *type_initial_value_c::visit(safeulint_type_name_c *symbol)    {return (void *)integer_0;}
void *type_initial_value_c::visit(safereal_type_name_c *symbol)     {return (void *)real_0;}
void *type_initial_value_c::visit(safelreal_type_name_c *symbol)    {return (void *)real_0;}
void *type_initial_value_c::visit(safedate_type_name_c *symbol)     {return (void *)date_0;}
void *type_initial_value_c::visit(safetod_type_name_c *symbol)      {return (void *)tod_0;}
void *type_initial_value_c::visit(safedt_type_name_c *symbol)       {return (void *)dt_0;}
void *type_initial_value_c::visit(safebyte_type_name_c *symbol)     {return (void *)integer_0;}
void *type_initial_value_c::visit(safeword_type_name_c *symbol)     {return (void *)integer_0;}
void *type_initial_value_c::visit(safedword_type_name_c *symbol)    {return (void *)integer_0;}
void *type_initial_value_c::visit(safelword_type_name_c *symbol)    {return (void *)integer_0;}
void *type_initial_value_c::visit(safestring_type_name_c *symbol)   {return (void *)string_0;}
void *type_initial_value_c::visit(safewstring_type_name_c *symbol)  {return (void *)wstring_0;}

/********************************/
/* B 1.3.3 - Derived data types */
/********************************/
/*  simple_type_name ':' simple_spec_init */
void *type_initial_value_c::visit(simple_type_declaration_c *symbol) {
  return symbol->simple_spec_init->accept(*this);
}
/* simple_specification ASSIGN constant */
void *type_initial_value_c::visit(simple_spec_init_c *symbol) {
  return handle_type_spec(symbol->simple_specification, symbol->constant);
}
/*  subrange_type_name ':' subrange_spec_init */
void *type_initial_value_c::visit(subrange_type_declaration_c *symbol) {
```<fitten@refcode>

path: czm2025/matiec/lib/test_iec_std_lib.c<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *
 *  Copyright (C) 2003-2011  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2007-2011  Laurent Bessard and Edouard Tisserant
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 *
 * Test bed for C implementation of standard IEC functions.
 *
 */

#include "iec_std_lib.h"

int main(int argc,char **argv)
{
        return 0;
}
```<fitten@refcode>

path: czm2025/matiec/readme<fitten@refcode>```would parse the st/il program and build the syntax tree.
Unfortunately the gcc syntax tree is not very well documented,
and doing semantic checking on this tree would probably be a
nightmare.
 We therefore chose to follow the same route as the gnat (ada 95)
and cobol compilers, i.e. generate our own abstract syntax tree,
do semantic checking on our tree, do whatever optimisation
we can at this level on our own tree, and only then build
the gcc syntax tree from our abstract syntax tree.
 All this may still be integrated with the gcc backend to generate
a new gnu compiler for the st and il programming languages.
Since generating the gcc syntax tree will probably envolve some
trial and error effort due to the sparseness of documentation,
we chose to start off by coding a C++ code generator for
our stage 4. We may later implement a gcc syntax tree generator
as an alternative stage 4 process, and then integrate it with
the gcc toplevel.c file (command line parsing, etc...).



****************************************************************
****************************************************************
****************************************************************
*********                                              *********
*********                                              *********
*********               S T A G E      1               *********
*********                                              *********
*********                                              *********
****************************************************************
****************************************************************
****************************************************************



Issue 1
=======

 The syntax defines the common_character_representation as:
<any printable character except '$', '"' or "'"> | <escape sequences>

 Flex includes the function print_char() that defines
all printable characters portably (i.e. whatever character
encoding is currently being used , ASCII, EBCDIC, etc...)
Unfortunately, we cannot generate the definition of
common_character_representation portably, since flex
does not allow definition of sets by subtracting
elements in one set from another set (Note how
common_character_representation could be defined by
subtracting '$' '"' and "'" from print_char() ).
This means we must build up the defintion of
common_character_representation using only set addition,
which leaves us with the only choice of defining the
characters non-portably...

 In short, the definition we use for common_character_representation
only works for ASCII character encoding!




Issue 2
=======

We extend the IEC 61131-3 standard syntax to allow inclusion of 
other files. The accepted syntax is:

   {#include "<filename>" }

We use a pragma directive for this (allowed by the standard itself),
 since it is an extension of the standard. In principle, this would 
be ignored by other standard complient compilers!



****************************************************************
****************************************************************
****************************************************************
*********                                              *********
*********                                              *********
*********               S T A G E      2               *********
*********                                              *********
*********                                              *********
****************************************************************
****************************************************************
****************************************************************

 Overall Comments
 ================

 
 Comment 1
 ---------
 We have augmented the syntax the specification defines to include
restrictions defined in the semantics of the languages.

 This is required because the syntax cannot be parsed by a LALR(1)
parser as it is presented in the specification. Many reduce/reduce
and shift/reduce conflicts arise. This is mainly because the parser
cannot discern how to reduce an identifier. Identifiers show up in
many places in the syntax, and it is not entirely possible to
figure out if the identifier is a variable_name, enumeration
value, function block name, etc... only from the context in
which it appears.

 A more detailed example of why we need symbol tables are
the type definitions...  In definition of new types
(section B 1.3.3) the parser needs to figure out the class of
the new type being defined (enumerated, structure, array, etc...).
This works well when the base classes are elementary types
(or structures, enumeration, arrays, etc. thereof). It becomes
confusing to the parser when the new_type is based on a previously
user defined type.

TYPE
  new_type_1 : INT := 99;
  new_type_2 : new_type_1 := 100;
END_TYPE

 When parsing new_type_1, the parser can figure out that the
identifier new_type_1 is a simple_type_name, because it is
based on a elementary type without structure, arrays, etc...
 While parsing new_type_2, it becomes confused how to reduce
the new_type_2 identifier, as it is based on the identifier
new_type_1, of which it does not know the class (remember, at this
stage new_type_1 is a simple identifier!).
 We therefore need to keep track of the class of the user
defined types as they are declared, so that the lexical analyser
can tell the syntax parser what class the type belongs to. We
cannot use the abstract syntax tree itself to search for the
declaration of new_type_1 as we only get a handle to the root
of the tree at the end of the parsing.

 We therefore maintain an independent and parallel table of symbols,
that is filled as we come across the type delcarations in the code.
Actually, we ended up also needing to store variable names in
the symbol table. Since variable names come and go out of scope
depending on what portion of code we are parsing, we sometimes
need to remove the variable names from the symbol table.
Since the ST and IL languages only have a single level of scope,
I (Mario) found it easier to simply use a second symbol table for
the variable names that is completely cleared when the parser
reaches the end of a function (function block or program).

What I mean when I say that these languages have a single level
of scope is that all variables used in a function (function block
or program) must be declared inside that function (function block
or program). Even global variables must be re-declared as EXTERN
before a function may access them! This means that it is easy
to simply load up the variable name symbol table when we start
parsing a function (function block or program), and to clear it
when we reach the end. Checking whether variables declared
as EXTERN really exist inside a RESOURCE or a CONFIGURATION
is left to stage 3 (semantic checking) where we can use the
abstract tree itself to search for the variables (NOTE: semantic
cheching at stage 3 has not yet been implemented, so we may yet
end up using a symbol table too at that stage!).

 Due to the use of the symbol tables, and special identifier
tokens depending on the type of identifier it had previously
been declared in the code being parsed, the syntax was slightly
changed regarding the definition of variable names, derived
function names, etc... FROM for e.g.:
variable_name: identifier;
TO
variable_name: variable_name_token;

 Flex first looks at the symbol tables when it finds an identifier,
and returns the correct token corresponding to the identifier
type in question. Only if the identifier is not currently stored
in any symbol table, does flex return a simple identifier_token.

 This means that the declarations of variables, functions etc...
were changed FROM:
function_declaration: FUNCTION derived_function_name ...
TO
function_declaration: FUNCTION identifier ...
since the initial definition of derived_function_name had been
changed FROM
derived_function_name: identifier;
TO
derived_function_name: derived_function_name_token;




 Comment 2
 ---------
 Since the ST and IL languages share a lot of common syntax,
I have decided to write a single parser to handle both languages
simultaneously. This approach has the advantage that the user
may mix the language used in the same file, as long as each function
is written in a single lanuage.

 This approach also assumes that all the IL language operators are
keywords, which means that it is not possible to define variables
using names such as "LD", "ST", etc...
Note that the spec does not consider these operators to be keywords,
so it means that they should be available for variable names! On the
other hand, all implementations of the ST and IL languages seems to
treat them as keywords, so there is not much harm in doing the same.

 If it ever becomes necessary to allow variables with names of IL 
operators, either the syntax will have to be augmented, or we can 
brake up the parser in two: one for ST and another for IL.



/********************************/
/* B 1.3.3 - Derived data types */
/********************************/

Issue 1
=======

According to the spec, the valid construct
TYPE new_str_type : STRING := "hello!"; END_TYPE
has two possible routes to type_declaration...

Route 1:
type_declaration: single_element_type_declaration
single_element_type_declaration: simple_type_declaration
simple_type_declaration: identifier ':' simple_spec_init
simple_spec_init: simple_specification ASSIGN constant
(shift:  identifier <- 'new_str_type')
simple_specification: elementary_type_name
elementary_type_name: STRING
(shift: elementary_type_name <- STRING)
(reduce: simple_specification <- elementary_type_name)
(shift: constant <- "hello!")
(reduce: simple_spec_init: simple_specification ASSIGN constant)
(reduce: ...)


Route 2:
type_declaration: string_type_declaration
string_type_declaration: identifier ':' elementary_string_type_name string_type_declaration_size string_type_declaration_init
(shift:  identifier <- 'new_str_type')
```<fitten@refcode>

path: czm2025/matiec/stage1_2/iec_flex.ll<fitten@refcode>``` *   sfc_qualifier_state -> pop() to sfc_state
 *                     (when no longer expecting an action qualifier. This transition is requested by bison)
 *
 *   config_state  -> push(config_state); goto(task_init_state)
 *                     (when parsing a task initialisation. This transition is requested by bison)
 *   task_init_state -> pop()
 *                     (when no longer parsing task initialisation parameters. This transition is requested by bison)
 *
 * 
 * There is another secondary state machine for parsing comments, another for file_includes, 
 * and yet another for time literals.
 */


/* Bison is in the pre-parsing stage, and we are parsing a POU. Ignore everything up to the end of the POU! */
%x ignore_pou_state
%x get_pou_name_state

/* we are parsing a configuration. */
%s config_state

/* Inside a configuration, we are parsing a task initialisation parameters */
/* This means that PRIORITY, SINGLE and INTERVAL must be handled as
 * tokens, and not as possible identifiers. Note that the above words
 * are not keywords.
 */
%s task_init_state

/* we are looking for the first VAR inside a function's, program's or function block's declaration */
/* This is not exclusive (%x) as we must be able to parse the identifier and data types of a function/FB */
%s header_state

/* we are parsing a function, program or function block sequence of VAR..END_VAR delcarations */
%x vardecl_list_state 
/* a substate of the vardecl_list_state: we are inside a specific VAR .. END_VAR */
%s vardecl_state

/* we will be parsing a function body/action/transition. Whether il/st/sfc remains to be determined */
%x body_state

/* we are parsing il code -> flex must return the EOL tokens!       */
%s il_state

/* we are parsing st code -> flex must not return the EOL tokens!   */
%s st_state

/* we are parsing sfc code -> flex must not return the EOL tokens!  */
%s sfc_state

/* we are parsing sfc code, and expecting an action qualifier.      */
%s sfc_qualifier_state

/* we are parsing sfc code, and expecting the priority token.       */
%s sfc_priority_state

/* we are parsing a TIME# literal. We must not return any {identifier} tokens. */
%x time_literal_state

/* we are parsing a comment. */
%x comment_state


/*******************/
/* File #include's */
/*******************/

/* We extend the IEC 61131-3 standard syntax to allow inclusion
 * of other files, using the IEC 61131-3 pragma directive...
 * The accepted syntax is:
 *  {#include "<filename>"}
 */

/* the "include" states are used for picking up the name of an include file */
%x include_beg
%x include_filename
%x include_end


file_include_pragma_filename	[^\"]*
file_include_pragma_beg		"{#include"{st_whitespace}\"
file_include_pragma_end		\"{st_whitespace}"}"
file_include_pragma			{file_include_pragma_beg}{file_include_pragma_filename}{file_include_pragma_end}


%{

/* A counter to track the order by which each token is processed.
 * NOTE: This counter is not exactly linear (i.e., it does not get incremented by 1 for each token).
 *       i.e.. it may get incremented by more than one between two consecutive tokens.
 *       This is due to the fact that the counter gets incremented every 'user action' in flex,
 *       however not every user action will result in a token being passed to bison.
 *       Nevertheless this is still OK, as we are only interested in the relative
 *       ordering of tokens...
 */
static long int current_order = 0;
  
typedef struct {
    int eof;
    int lineNumber;
    int currentChar;
    int lineLength;
    int currentTokenStart;
    FILE *in_file;
  } tracking_t;

/* A forward declaration of a function defined at the end of this file. */
void FreeTracking(tracking_t *tracking);


#define MAX_INCLUDE_DEPTH 16

typedef struct {
	  YY_BUFFER_STATE buffer_state;
	  tracking_t *env;
	  const char *filename;
	} include_stack_t;

tracking_t * current_tracking = NULL;
tracking_t  previous_tracking;
include_stack_t include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;

const char *INCLUDE_DIRECTORIES[] = {
	DEFAULT_LIBDIR,
	".",
	"/lib",
	"/usr/lib",
	"/usr/lib/iec",
	NULL /* must end with NULL!! */
	};
%}



/*****************************/
/* Prelimenary constructs... */
/*****************************/

/* PRAGMAS */
/* ======= */
/* In order to allow the declaration of POU prototypes (Function, FB, Program, ...),
 * especially the prototypes of Functions and FBs defined in the standard
 * (i.e. standard functions and FBs), we extend the IEC 61131-3 standard syntax 
 * with two pragmas to indicate that the code is to be parsed (going through the 
 * lexical, syntactical, and semantic analysers), but no code is to be generated.
 * 
 * The accepted syntax is:
 *  {no_code_generation begin}
 *    ... prototypes ...
 *  {no_code_generation end}
 * 
 * When parsing these prototypes the abstract syntax tree will be populated as usual,
 * allowing the semantic analyser to correctly analyse the semantics of calls to these
 * functions/FBs. However, stage4 will simply ignore all IEC61131-3 code
 * between the above two pragmas.
 */

disable_code_generation_pragma	"{disable code generation}"
enable_code_generation_pragma	"{enable code generation}"


/* Any other pragma... */
pragma ("{"[^}]*"}")|("{{"([^}]|"}"[^}])*"}}")



/* COMMENTS */
/* ======== */

/* In order to allow nested comments, comments are handled by a specific comment_state state */
/* Whenever a "(*" is found, we push the current state onto the stack, and enter a new instance of the comment_state state.
 * Whenever a "*)" is found, we pop a state off the stack
 */

/* comments... */
comment_beg  "(*"
comment_end  "*)"

/* However, bison has a shift/reduce conflict in bison, when parsing formal function/FB
 * invocations with the 'NOT <variable_name> =>' syntax (which needs two look ahead 
 * tokens to be parsed correctly - and bison being LALR(1) only supports one).
 * The current work around requires flex to completely parse the '<variable_name> =>'
 * sequence. This sequence includes whitespace and/or comments between the 
 * <variable_name> and the "=>" token.
 * 
 * This flex rule (sendto_identifier_token) uses the whitespace/comment as trailing context,
 * which means we can not use the comment_state method of specifying/finding and ignoring 
 * comments.
 * 
 * For this reason only, we must also define what a complete comment looks like, so
 * it may be used in this rule. Since the rule uses the whitespace_or_comment
 * construct as trailing context, this definition of comment must not use any
 * trailing context either.
 * 
 * Aditionally, it is not possible to define nested comments in flex without the use of
 * states, so for this particular location, we do NOT support nested comments.
 */
/* NOTE: this seemingly unnecessary complex definition is required
 *       to be able to eat up comments such as:
 *          '(* Testing... ! ***** ******)'
 *       without using the trailing context command in flex (/{context})
 *       since {comment} itself will later be used with
 *       trailing context ({comment}/{context})
 */
not_asterisk				[^*]
not_close_parenthesis_nor_asterisk	[^*)]
asterisk				"*"
comment_text	({not_asterisk})|(({asterisk}+){not_close_parenthesis_nor_asterisk})
comment		"(*"({comment_text}*)({asterisk}+)")"



/* 3.1 Whitespace */
/* ============== */
/*
 * Whitespace is clearly defined (see IEC 61131-3 v2, section 2.1.4)
 * 
 * Whitespace definition includes the newline character.
 * 
 * However, the standard is inconsistent in that in IL the newline character 
 * is considered a token (EOL - end of line). 
 * In our implementation we therefore have two definitions of whitespace
 *   - one for ST, that includes the newline character
 *   - one for IL without the newline character.
 *
 * IL whitespace is only active while parsing IL code, whereas ST whitespace
 * is used in all other circumstances. Additionally, when parsing IL, the newline
 * character is treated as the EOL token.
 * The above requires the use of a state machine in the lexical parser to track which
 * language is being parsed. This requires that the lexical parser (i.e. flex)
 * have some knowledge of the syntax itself.
 *
 * NOTE: Our definition of whitespace will only work in ASCII!
 *
 * NOTE: we cannot use
 *         st_whitespace	[:space:]*
 *       since we use {st_whitespace} as trailing context. In our case
 *       this would not constitute "dangerous trailing context", but the
 *       lexical generator (i.e. flex) does not know this (since it does
 *       not know which characters belong to the set [:space:]), and will
 *       generate a "dangerous trailing context" warning!
 *       We use this alternative just to stop the flex utility from
 *       generating the invalid (in this case) warning...
 */
/* NOTE: il_whitespace_char is not currenty used, be we include it for completeness */ 
st_whitespace_char		[ \f\n\r\t\v]
il_whitespace_char		[ \f\r\t\v]

st_whitespace			[ \f\n\r\t\v]*
il_whitespace			[ \f\r\t\v]*

st_whitespace_or_pragma_or_commentX	({st_whitespace})|({pragma})|({comment})
il_whitespace_or_pragma_or_commentX	({il_whitespace})|({pragma})|({comment})

st_whitespace_or_pragma_or_comment	{st_whitespace_or_pragma_or_commentX}*
il_whitespace_or_pragma_or_comment	{il_whitespace_or_pragma_or_commentX}*



qualified_identifier	{identifier}(\.{identifier})+



/*****************************************/
/* B.1.1 Letters, digits and identifiers */
/*****************************************/
/* NOTE: The following definitions only work if the host computer
 *       is using the ASCII maping. For e.g., with EBCDIC [A-Z]
 *       contains non-alphabetic characters!
 *       The correct way of doing it would be to use
 *       the [:upper:] etc... definitions.
 *
 *       Unfortunately, further on we need all printable
 *       characters (i.e. [:print:]), but excluding '$'.
 *       Flex does not allow sets to be composed by excluding
 *       elements. Sets may only be constructed by adding new
```<fitten@refcode>

path: czm2025/matiec/stage3/print_datatypes_error.cc<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *
 *  Copyright (C) 2009-2011  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2011-2012 Manuele Conti (manuele.conti@sirius-es.it)
 *  Copyright (C) 2011-2012 Matteo Facchinetti (matteo.facchinetti@sirius-es.it)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/*
 * An IEC 61131-3 compiler.
 *
 * Based on the
 * FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)
 *
 */

/* NOTE: The algorithm implemented here assumes that the symbol_c.candidate_datatype, and the symbol_c.datatype 
 *       annotations have already been apropriately filled in!
 *       BEFORE running this visitor, be sure to CALL the fill_candidate_datatypes_c, and the narrow_candidate_datatypes_c visitors!
 */


/*
 *  By analysing the candidate datatype lists, as well as the chosen datatype for each expression, determine
 *  if an datatype error has been found, and if so, print out an error message.
 */


#include "print_datatypes_error.hh"
#include "datatype_functions.hh"

#include <typeinfo>
#include <list>
#include <string>
#include <string.h>
#include <strings.h>






#define FIRST_(symbol1, symbol2) (((symbol1)->first_order < (symbol2)->first_order)   ? (symbol1) : (symbol2))
#define  LAST_(symbol1, symbol2) (((symbol1)->last_order  > (symbol2)->last_order)    ? (symbol1) : (symbol2))

#define STAGE3_ERROR(error_level, symbol1, symbol2, ...) {                                                                  \
  if (current_display_error_level >= error_level) {                                                                         \
    fprintf(stderr, "%s:%d-%d..%d-%d: error: ",                                                                             \
            FIRST_(symbol1,symbol2)->first_file, FIRST_(symbol1,symbol2)->first_line, FIRST_(symbol1,symbol2)->first_column,\
                                                 LAST_(symbol1,symbol2) ->last_line,  LAST_(symbol1,symbol2) ->last_column);\
    fprintf(stderr, __VA_ARGS__);                                                                                           \
    fprintf(stderr, "\n");                                                                                                  \
    il_error = true;                                                                                                        \
    error_count++;                                                                                                     \
  }                                                                                                                         \
}  


#define STAGE3_WARNING(symbol1, symbol2, ...) {                                                                             \
    fprintf(stderr, "%s:%d-%d..%d-%d: warning: ",                                                                           \
            FIRST_(symbol1,symbol2)->first_file, FIRST_(symbol1,symbol2)->first_line, FIRST_(symbol1,symbol2)->first_column,\
                                                 LAST_(symbol1,symbol2) ->last_line,  LAST_(symbol1,symbol2) ->last_column);\
    fprintf(stderr, __VA_ARGS__);                                                                                           \
    fprintf(stderr, "\n");                                                                                                  \
    warning_found = true;                                                                                                   \
}  


/* set to 1 to see debug info during execution */
static int debug = 0;

print_datatypes_error_c::print_datatypes_error_c(symbol_c *ignore) {
	error_count = 0;
	warning_found = false;
	current_display_error_level = error_level_default;
}

print_datatypes_error_c::~print_datatypes_error_c(void) {
}

int print_datatypes_error_c::get_error_count() {
	return error_count;
}





/* Verify if the datatypes of all symbols in the vector are valid and equal!  */
static bool are_all_datatypes_equal(std::vector <symbol_c *> &symbol_vect) {
	if (symbol_vect.size() <= 0) return false;

	bool res = get_datatype_info_c::is_type_valid(symbol_vect[0]->datatype);
	for (unsigned int i = 1; i < symbol_vect.size(); i++)
		res &= get_datatype_info_c::is_type_equal(symbol_vect[i-1]->datatype, symbol_vect[i]->datatype);	
	return res;
}





/*
typedef struct {
  symbol_c *function_name,
  symbol_c *nonformal_operand_list,
  symbol_c *   formal_operand_list,

  std::vector <symbol_c *> &candidate_functions,  
  symbol_c &*called_function_declaration,
  int      &extensible_param_count
} generic_function_call_t;
*/
void print_datatypes_error_c::handle_function_invocation(symbol_c *fcall, generic_function_call_t fcall_data) {
	symbol_c *param_value, *param_name;
	function_call_param_iterator_c fcp_iterator(fcall);
	bool function_invocation_error = false;
	const char *POU_str = NULL;

	if (generic_function_call_t::POU_FB       == fcall_data.POU_type)  POU_str = "FB";
	if (generic_function_call_t::POU_function == fcall_data.POU_type)  POU_str = "function";
	if (NULL == POU_str) ERROR;

	if ((NULL != fcall_data.formal_operand_list) && (NULL != fcall_data.nonformal_operand_list)) 
		ERROR;

	symbol_c *f_decl = fcall_data.called_function_declaration;
	if ((NULL == f_decl) && (generic_function_call_t::POU_FB ==fcall_data.POU_type)) {
		/* Due to the way the syntax analysis is buit (i.e. stage 2), this should never occur. */
		/* I.e., a FB invocation using an undefined FB variable is not possible in the current implementation of stage 2. */
		ERROR;
	}
	if (NULL == f_decl) {
		/* we now try to find any function declaration with the same name, just so we can provide some relevant error messages */
		function_symtable_t::iterator lower = function_symtable.lower_bound(fcall_data.function_name);
		if (lower == function_symtable.end()) ERROR;
		f_decl = function_symtable.get_value(lower);
	}

	if (NULL != fcall_data.formal_operand_list) {
		fcall_data.formal_operand_list->accept(*this);
		if (NULL != f_decl) {
			function_param_iterator_c fp_iterator(f_decl);
			while ((param_name = fcp_iterator.next_f()) != NULL) {
				param_value = fcp_iterator.get_current_value();
				
				/* Check if there are duplicate parameter values */
				if(fcp_iterator.search_f(param_name) != param_value) {
					function_invocation_error = true;
					STAGE3_ERROR(0, param_name, param_name, "Duplicate parameter '%s' when invoking %s '%s'", ((token_c *)param_name)->value, POU_str, ((token_c *)fcall_data.function_name)->value);
					continue; /* jump to next parameter */
				}

				/* Find the corresponding parameter in function declaration */
				if (NULL == fp_iterator.search(param_name)) {
					function_invocation_error = true;
					STAGE3_ERROR(0, param_name, param_name, "Invalid parameter '%s' when invoking %s '%s'", ((token_c *)param_name)->value, POU_str, ((token_c *)fcall_data.function_name)->value);
					continue; /* jump to next parameter */
				} 

				/* check whether direction (IN, OUT, IN_OUT) and assignment types (:= , =>) are compatible !!! */
				/* Obtaining the assignment direction:  := (assign_in) or => (assign_out) */
				function_call_param_iterator_c::assign_direction_t call_param_dir = fcp_iterator.get_assign_direction();
				/* Get the parameter direction: IN, OUT, IN_OUT */
				function_param_iterator_c::param_direction_t param_dir = fp_iterator.param_direction();
				if          (function_call_param_iterator_c::assign_in  == call_param_dir) {
					if ((function_param_iterator_c::direction_in    != param_dir) &&
					    (function_param_iterator_c::direction_inout != param_dir)) {
						function_invocation_error = true;
						STAGE3_ERROR(0, param_name, param_name, "Invalid assignment syntax ':=' used for parameter '%s', when invoking %s '%s'", ((token_c *)param_name)->value, POU_str, ((token_c *)fcall_data.function_name)->value);
						continue; /* jump to next parameter */
					}
				} else if   (function_call_param_iterator_c::assign_out == call_param_dir) {
					if ((function_param_iterator_c::direction_out   != param_dir)) {
						function_invocation_error = true;
						STAGE3_ERROR(0, param_name, param_name, "Invalid assignment syntax '=>' used for parameter '%s', when invoking %s '%s'", ((token_c *)param_name)->value, POU_str, ((token_c *)fcall_data.function_name)->value);
						continue; /* jump to next parameter */
					}
				} else ERROR;

				if (!get_datatype_info_c::is_type_valid(param_value->datatype)) {
					function_invocation_error = true;
					STAGE3_ERROR(0, param_value, param_value, "Data type incompatibility between parameter '%s' and value being passed, when invoking %s '%s'", ((token_c *)param_name)->value, POU_str, ((token_c *)fcall_data.function_name)->value);
					continue; /* jump to next parameter */
				}
			}
		}
	}
	if (NULL != fcall_data.nonformal_operand_list) {
		if (f_decl)
			for (int i = 1; (param_value = fcp_iterator.next_nf()) != NULL; i++) {
		  		/* TODO: verify if it is lvalue when INOUT or OUTPUT parameters! */

				/* This handle_function_invocation() will be called to handle IL function calls, where the first parameter comes from the previous IL instruction.
				 * In this case, the previous IL instruction will be artifically (and temporarily) added to the begining ot the parameter list
```<fitten@refcode>

path: czm2025/matiec/stage4/generate_c/generate_c_il.cc<fitten@refcode>```void *visit(CLK_operator_c *symbol)	{return XXX_CAL_operator("CLK", this->current_operand);}
void *visit( CU_operator_c *symbol)	{return XXX_CAL_operator( "CU", this->current_operand);}
void *visit( CD_operator_c *symbol)	{return XXX_CAL_operator( "CD", this->current_operand);}
void *visit( PV_operator_c *symbol)	{return XXX_CAL_operator( "PV", this->current_operand);}
void *visit( IN_operator_c *symbol)	{return XXX_CAL_operator( "IN", this->current_operand);}
void *visit( PT_operator_c *symbol)	{return XXX_CAL_operator( "PT", this->current_operand);}

void *visit(AND_operator_c *symbol) {
  if (!get_datatype_info_c::is_ANY_BIT_compatible(symbol->datatype)) ERROR;
  XXX_operator(&(this->implicit_variable_result), " &= ", this->current_operand);
  return NULL;
}

void *visit(OR_operator_c *symbol) {
  if (!get_datatype_info_c::is_ANY_BIT_compatible(symbol->datatype)) ERROR;
  XXX_operator(&(this->implicit_variable_result), " |= ", this->current_operand);
  return NULL;
}

void *visit(XOR_operator_c *symbol) {
  if (!get_datatype_info_c::is_ANY_BIT_compatible(symbol->datatype)) ERROR;
  // '^' is a bit by bit exclusive OR !! Also seems to work with boolean types!
  XXX_operator(&(this->implicit_variable_result), " ^= ", this->current_operand);
  return NULL;
}

void *visit(ANDN_operator_c *symbol) {
  if (!get_datatype_info_c::is_ANY_BIT_compatible(symbol->datatype)) ERROR;
  XXX_operator(&(this->implicit_variable_result), get_datatype_info_c::is_BOOL_compatible(this->current_operand->datatype)?" &= !":" &= ~", this->current_operand);
  return NULL;
}

void *visit(ORN_operator_c *symbol) {
  if (!get_datatype_info_c::is_ANY_BIT_compatible(symbol->datatype)) ERROR;
  XXX_operator(&(this->implicit_variable_result), get_datatype_info_c::is_BOOL_compatible(this->current_operand->datatype)?" |= !":" |= ~", this->current_operand);
  return NULL;
}

void *visit(XORN_operator_c *symbol) {
  if (!get_datatype_info_c::is_ANY_BIT_compatible(symbol->datatype)) ERROR;
  // bit by bit exclusive OR !! Also seems to work with boolean types!
  XXX_operator(&(this->implicit_variable_result), get_datatype_info_c::is_BOOL_compatible(this->current_operand->datatype)?" ^= !":" ^= ~", this->current_operand);
  return NULL;
}

void *visit(ADD_operator_c *symbol) {
  if (get_datatype_info_c::is_TIME_compatible(symbol->datatype) || get_datatype_info_c::is_ANY_DATE_compatible  (symbol->datatype)) 
        XXX_function(&(this->implicit_variable_result), "__time_add", &(this->implicit_variable_current), this->current_operand);
  else  XXX_operator(&(this->implicit_variable_result), " += ", this->current_operand);
  return NULL;
}

void *visit(SUB_operator_c *symbol) {
  if (get_datatype_info_c::is_TIME_compatible(symbol->datatype) || get_datatype_info_c::is_ANY_DATE_compatible  (symbol->datatype))
        XXX_function(&(this->implicit_variable_result), "__time_sub", &(this->implicit_variable_current), this->current_operand);
  else  XXX_operator(&(this->implicit_variable_result), " -= ", this->current_operand);
  return NULL;
}

void *visit(MUL_operator_c *symbol) {
  if (get_datatype_info_c::is_TIME_compatible(symbol->datatype))
        XXX_function(&(this->implicit_variable_result), "__time_mul", &(this->implicit_variable_current), this->current_operand);
  else  XXX_operator(&(this->implicit_variable_result), " *= ", this->current_operand);
  return NULL;
}

void *visit(DIV_operator_c *symbol) {
  if (get_datatype_info_c::is_TIME_compatible(symbol->datatype))
        XXX_function(&(this->implicit_variable_result), "__time_div", &(this->implicit_variable_current), this->current_operand);
  else  XXX_operator(&(this->implicit_variable_result), " /= ", this->current_operand);
  return NULL;
}

void *visit(MOD_operator_c *symbol)	{XXX_operator(&(this->implicit_variable_result), " %= ", this->current_operand); return NULL;}

void *visit(GT_operator_c *symbol)	{CMP_operator(this->current_operand, "GT"); return NULL;}
void *visit(GE_operator_c *symbol)	{CMP_operator(this->current_operand, "GE"); return NULL;}
void *visit(EQ_operator_c *symbol)	{CMP_operator(this->current_operand, "EQ"); return NULL;}
void *visit(LT_operator_c *symbol)	{CMP_operator(this->current_operand, "LT"); return NULL;}
void *visit(LE_operator_c *symbol)	{CMP_operator(this->current_operand, "LE"); return NULL;}
void *visit(NE_operator_c *symbol)	{CMP_operator(this->current_operand, "NE"); return NULL;}


//SYM_REF0(CAL_operator_c)
// This method will be called from within the il_fb_call_c visitor method
void *visit(CAL_operator_c *symbol) {return NULL;}

//SYM_REF0(CALC_operator_c)
// This method will be called from within the il_fb_call_c visitor method
void *visit(CALC_operator_c *symbol) {C_modifier(); return NULL;}

//SYM_REF0(CALCN_operator_c)
// This method will be called from within the il_fb_call_c visitor method
void *visit(CALCN_operator_c *symbol) {CN_modifier(); return NULL;}

/* NOTE: The semantics of the RET operator requires us to return a value
 *       if the IL code is inside a function, but simply return no value if
 *       the IL code is inside a function block or program!
 *       Nevertheless, it is the generate_c_c class itself that
 *       introduces the 'reaturn <value>' into the c++ code at the end
 *       of every function. This class does not know whether the IL code
 *       is inside a function or a function block.
 *       We work around this by jumping to the end of the code,
 *       that will be marked by the END_LABEL label in the
 *       instruction_list_c visitor...
 */
// SYM_REF0(RET_operator_c)
void *visit(RET_operator_c *symbol) {
  s4o.print("goto ");s4o.print(END_LABEL);
  return NULL;
}

// SYM_REF0(RETC_operator_c)
void *visit(RETC_operator_c *symbol) {
  C_modifier();
  s4o.print("goto ");s4o.print(END_LABEL);
  return NULL;
}

// SYM_REF0(RETCN_operator_c)
void *visit(RETCN_operator_c *symbol) {
  CN_modifier();
  s4o.print("goto ");s4o.print(END_LABEL);
  return NULL;
}

//SYM_REF0(JMP_operator_c)
void *visit(JMP_operator_c *symbol) {
  if (NULL == this->jump_label) ERROR;
  s4o.print("goto ");
  this->jump_label->accept(*this);
  return NULL;
}

// SYM_REF0(JMPC_operator_c)
void *visit(JMPC_operator_c *symbol) {
  if (NULL == this->jump_label) ERROR;
  C_modifier();
  s4o.print("goto ");
  this->jump_label->accept(*this);
  return NULL;
}

// SYM_REF0(JMPCN_operator_c)
void *visit(JMPCN_operator_c *symbol) {
  if (NULL == this->jump_label) ERROR;
  CN_modifier();
  s4o.print("goto ");
  this->jump_label->accept(*this);
  return NULL;
}

#if 0
/*| [NOT] any_identifier SENDTO */
SYM_REF2(il_assign_out_operator_c, option, variable_name)
#endif

}; /* generate_c_il_c */









/* The implementation of the single visit() member function
 * of il_default_variable_c.
 * It can only come after the full declaration of
 * generate_c_il_c. Since we define and declare
 * generate_c_il_c simultaneously, it can only come
 * after the definition...
 */
void *il_default_variable_c::accept(visitor_c &visitor) {
  /* An ugly hack!! */
  /* This is required because we need to over-ride the base
   * accept(visitor_c &) method of the class symbol_c,
   * so this method may be called through a symbol_c *
   * reference!
   *
   * But, the visitor_c does not include a visitor to
   * an il_default_variable_c, which means that we couldn't
   * simply call visitor.visit(this);
   *
   * We therefore need to use the dynamic_cast hack!!
   *
   * Note too that we can't cast a visitor_c to a
   * il_default_variable_visitor_c, since they are not related.
   * Nor may the il_default_variable_visitor_c inherit from
   * visitor_c, because then generate_c_il_c would contain
   * two visitor_c base classes, one each through
   * il_default_variable_visitor_c and generate_c_type_c
   *
   * We could use virtual inheritance of the visitor_c, but it
   * would probably create more problems than it is worth!
   */
  generate_c_il_c *v;
  v = dynamic_cast<generate_c_il_c *>(&visitor);
  if (v == NULL) ERROR;

  return v->visit(this);
}




il_default_variable_c::il_default_variable_c(const char *var_name_str, symbol_c *current_type) {
  if (NULL == var_name_str) ERROR;
  /* Note: current_type may start off with NULL */

  this->var_name = new identifier_c(var_name_str);
  if (NULL == this->var_name) ERROR;

  this->datatype = current_type;
}
```<fitten@refcode>

path: czm2025/matiec/stage4/generate_c/generate_c_vardecl.cc<fitten@refcode>```   * visitor, as they apply here too.
   */

  /* Start off by setting the current_var_type_symbol and
   * current_var_init_symbol private variables...
   */
  update_type_init(symbol->type_specification);

  /* now to produce the c equivalent... */
  symbol->global_var_spec->accept(*this);

  /* Values no longer in scope, and therefore no longer used.
   * Make an effort to keep them set to NULL when not in use
   * in order to catch bugs as soon as possible...
   */
  void_type_init();

  return NULL;
}


/*| global_var_name location */
// SYM_REF2(global_var_spec_c, global_var_name, location)
void *visit(global_var_spec_c *symbol) {
  TRACE("global_var_spec_c");
  /* now to produce the c equivalent... */
  switch(wanted_varformat) {
    case local_vf:
      s4o.print(s4o.indent_spaces);
      s4o.print(DECLARE_GLOBAL_LOCATION);
      s4o.print("(");
      this->current_var_type_symbol->accept(*this);
      s4o.print(",");
      symbol->location->accept(*this);
      s4o.print(")\n");
      if (symbol->global_var_name != NULL) {
        s4o.print(s4o.indent_spaces);
        s4o.print(DECLARE_GLOBAL_LOCATED);
        s4o.print("(");
        this->current_var_type_symbol->accept(*this);
        s4o.print(",");
        if (this->resource_name != NULL) {
            this->resource_name->accept(*this);
        }
        s4o.print(",");
        symbol->global_var_name->accept(*this);
        s4o.print(")\n");
      }
      break;

    case constructorinit_vf:
      if (symbol->global_var_name != NULL) {
        s4o.print(nv->get());
        s4o.print(INIT_GLOBAL_LOCATED);
        s4o.print("(");
        if (this->resource_name != NULL) {
          this->resource_name->accept(*this);
        }
        s4o.print(",");
        symbol->global_var_name->accept(*this);
        s4o.print(",");
        symbol->location->accept(*this);
        print_retain();
        s4o.print(")");
      }
      if (this->current_var_init_symbol != NULL) {
        s4o.print(nv->get());
        s4o.print(INIT_GLOBAL);
        s4o.print("(");
        this->current_var_type_symbol->accept(*this);
        s4o.print(",");
        if (symbol->global_var_name != NULL)
          symbol->global_var_name->accept(*this);
        else
	      symbol->location->accept(*this);
        s4o.print(",");
        s4o.print(INITIAL_VALUE);
        s4o.print("(");
        this->current_var_init_symbol->accept(*this);
        s4o.print(")");
        print_retain();
        s4o.print(")");
      }
      break;
    
    case globalprototype_vf:
      s4o.print(s4o.indent_spaces);
      s4o.print(DECLARE_GLOBAL_PROTOTYPE);
      s4o.print("(");
      this->current_var_type_symbol->accept(*this);
      s4o.print(",");
      if (symbol->global_var_name != NULL)
        symbol->global_var_name->accept(*this);
      else
        symbol->location->accept(*this);
      s4o.print(")\n");
      break;
    
    case location_list_vf:
      print_located_var_list_item
      break;

    default:
      ERROR;
  } /* switch() */

  return NULL;
}



/*  AT direct_variable */
// SYM_REF2(location_c, direct_variable, unused)
void *visit(location_c *symbol) {
  TRACE("location_c");
  return symbol->direct_variable->accept(*this);
}


/*| global_var_list ',' global_var_name */
//SYM_LIST(global_var_list_c)
void *visit(global_var_list_c *symbol) {
  TRACE("global_var_list_c");
  list_c *list = dynamic_cast<list_c *>(symbol);
  if(!get_datatype_info_c::is_type_valid(this->current_var_type_symbol)) ERROR;
  bool is_fb = get_datatype_info_c::is_function_block(this->current_var_type_symbol);
  /* should NEVER EVER occur!! */
  if (list == NULL) ERROR;

  /* now to produce the c equivalent... */
  switch (wanted_varformat) {
    case local_vf:
    case localinit_vf:
      for(int i = 0; i < list->n; i++) {
        s4o.print(s4o.indent_spaces);
        if (is_fb)
          s4o.print(DECLARE_GLOBAL_FB);
        else
          s4o.print(DECLARE_GLOBAL);
        s4o.print("(");
        this->current_var_type_symbol->accept(*this);
        s4o.print(",");
        if(this->resource_name != NULL)
            this->resource_name->accept(*this);
        s4o.print(",");
        list->get_element(i)->accept(*this);
        s4o.print(")\n");
      }
      break;

    case constructorinit_vf:
      if (this->current_var_init_symbol != NULL || is_fb) {
        for(int i = 0; i < list->n; i++) {
          s4o.print(nv->get());

          if (is_fb)
            s4o.print(INIT_GLOBAL_FB);
          else
            s4o.print(INIT_GLOBAL);
          s4o.print("(");
          this->current_var_type_symbol->accept(*this);
          s4o.print(",");
          list->get_element(i)->accept(*this);
          if (this->current_var_init_symbol != NULL) {
            s4o.print(",");
            s4o.print(INITIAL_VALUE);
            s4o.print("(");
            this->current_var_init_symbol->accept(*this);
            s4o.print(")");
          }
          print_retain();
          s4o.print(")");
          current_varqualifier = none_vq;
#if 0
      /* The following code would be for globalinit_vf !!
       * But it is not currently required...
       */
      s4o.print(s4o.indent_spaces + "__ext_element_c<");
          this->current_var_type_symbol->accept(*this);
          s4o.print("> ");
          if (this->globalnamespace != NULL) {
            this->globalnamespace->accept(*this);
            s4o.print("::");
          }
          list->get_element(i)->accept(*this);

          if (this->current_var_init_symbol != NULL) {
            s4o.print(" = ");
            s4o.print("__ext_element_c<");
            this->current_var_type_symbol->accept(*this);
            s4o.print(">(");
            this->current_var_init_symbol->accept(*this);
            s4o.print(")");
      }
          s4o.print(";\n");
#endif
        }
      }
      break;

    case globalprototype_vf:
      for(int i = 0; i < list->n; i++) {
        s4o.print(s4o.indent_spaces);
        s4o.print(DECLARE_GLOBAL_PROTOTYPE);
        s4o.print("(");
        this->current_var_type_symbol->accept(*this);
        s4o.print(",");
        list->get_element(i)->accept(*this);
        s4o.print(")\n");
      }
      break;

    case location_list_vf:
      for(int i = 0; i < list->n; i++) {
        list->get_element(i)->accept(*this);
      }
      break;

    default:
      ERROR; /* not supported, and not needed either... */
  }

  return NULL;
}


#if 0
/*  var1_list ':' single_byte_string_spec */
SYM_REF2(single_byte_string_var_declaration_c, var1_list, single_byte_string_spec)

/*  STRING ['[' integer ']'] [ASSIGN single_byte_character_string] */
/* integer ->may be NULL ! */
/* single_byte_character_string ->may be NULL ! */
SYM_REF2(single_byte_string_spec_c, integer, single_byte_character_string)

/*  var1_list ':' double_byte_string_spec */
SYM_REF2(double_byte_string_var_declaration_c, var1_list, double_byte_string_spec)

/*  WSTRING ['[' integer ']'] [ASSIGN double_byte_character_string] */
/* integer ->may be NULL ! */
/* double_byte_character_string ->may be NULL ! */
SYM_REF2(double_byte_string_spec_c, integer, double_byte_character_string)

/*| VAR [RETAIN|NON_RETAIN] incompl_located_var_decl_list END_VAR */
/* option ->may be NULL ! */
SYM_REF2(incompl_located_var_declarations_c, option, incompl_located_var_decl_list)

/* helper symbol for incompl_located_var_declarations */
/*| incompl_located_var_decl_list incompl_located_var_decl ';' */
SYM_LIST(incompl_located_var_decl_list_c)

/*  variable_name incompl_location ':' var_spec */
SYM_REF4(incompl_located_var_decl_c, variable_name, incompl_location, var_spec, unused)

/*  AT incompl_location_token */
SYM_TOKEN(incompl_location_c)
#endif


void *visit(falling_edge_option_c *symbol) {
  // TO DO ...
  s4o.print("F_EDGE");
  return NULL;
}


void *visit(var1_init_decl_c *symbol) {
  TRACE("var1_init_decl_c");
  /* We have several implementation alternatives here...
   *
   * The issue is that generation of c code
   * based on the abstract syntax tree requires the reversal
   * of the symbol order compared to st. For e.g.:
   * (ST) a, b, c: INT := 98;
   * (C ) int a=98, b=98, c=98;
   * The spec_init contains the references to 'INT' and '98'.
   * The var1_list contains the references to 'a', 'b', and 'c'.
   * The var1_init_decl_c contains the references to spec_init and var1_list.
   *
   * For c code generation, the var1_init_decl_c visitor
   * would need to access the internals of other classes
   * (e.g. the simple_spec_init_c).
   *
   * We can do this using one of three methods:
   *   1) Create the abstract syntax tree differently;
   *   2) Access other classes from within the var1_init_decl_c;
   *   3) Pass info between the visitors using global variables
   *       only acessible by this class (private vars)
   *
   * In 1), the abstract syntax tree would be built so that
   * var1_init_decl_c would contain direct references to
   * var1_list_c, to the var type 'INT' and to the initialiser '98'
   * (as per the example above).
   *
   * 2) would have several sub-options to obtain the references
   * to 'INT' and '98' from within var1_init_decl_c.
   *  In 2a), the var1_init_decl_c would use dynamic casts to determine
   * the class of spec_init (simple_spec_init_c, subrange_spec_init_c or
   * enumerated_spec_init_c), and from there obtain the 'INT' and '98'
   *  In 2b) var1_init_decl_c would have one reference for each
   * simple_spec_init_c, subrange_spec_init_c and enumerated_spec_init_c,
   * the apropriate one being initialised by the var1_init_decl_c constructor.
   * Note that the constructor would use dynamic casts. In essence, we
   * would merely be changing the location of the code with the
   * dynamic casts.
   *  In 2c) we would use three overloaded constructors for var1_init_decl_c
   * one each for simple_spec_init_c, etc... This implies
   * use type specific pointers to each symbol in the bison
   * parser, instead of simply using a symbol_c * for all symbols;
```<fitten@refcode>

path: czm2025/matiec/tests/plc.c<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *
 *  Copyright (C) 2009-2011  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2007-2011  Laurent Bessard and Edouard Tisserant
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 *
 *
 * Simple PLC run cycle test implementation - prints every located at each cycle
 *
 */

#include "iec_std_lib.h"
#include <stdio.h>

#define __print_BOOL(name) printf("  %s = (BOOL) %s\n",#name, name?"TRUE":"FALSE");
#define __print_SINT(name) printf("  %s = (SINT) %d\n",#name, name);
#define __print_INT(name) printf("  %s = (INT) %d\n",#name, name);
#define __print_DINT(name) printf("  %s = (DINT) %d\n",#name, name);
#define __print_LINT(name) printf("  %s = (LINT) %d\n",#name, name);
#define __print_USINT(name) printf("  %s = (USINT) %u\n",#name, name);
#define __print_UINT(name) printf("  %s = (UINT) %u\n",#name, name);
#define __print_UDINT(name) printf("  %s = (UDINT) %u\n",#name, name);
#define __print_ULINT(name) printf("  %s = (ULINT) %lu\n",#name, name);
#define __print_REAL(name) printf("  %s = (REAL) %f\n",#name, (double)name);
#define __print_LREAL(name) printf("  %s = (LREAL) %f\n",#name, (double)name);
#define __print_TIME(name) {STRING __tmp = __time_to_string(name);__tmp.body[__tmp.len] = 0; printf("  %s = (TIME) %*s\n",#name, __tmp.len, &__tmp.body);}
#define __print_DATE(name) {STRING __tmp = __date_to_string(name);__tmp.body[__tmp.len] = 0; printf("  %s = (DATE) %*s\n",#name, __tmp.len, &__tmp.body);}
#define __print_TOD(name) {STRING __tmp = __tod_to_string(name);__tmp.body[__tmp.len] = 0; printf("  %s = (TOD) %*s\n",#name, __tmp.len, &__tmp.body);}
#define __print_DT(name) {STRING __tmp = __dt_to_string(name);__tmp.body[__tmp.len] = 0; printf("  %s = (DT) %*s\n",#name, __tmp.len, &__tmp.body);}
#define __print_STRING(name) printf("  %s = (STRING) {%d, \"%*s\"}\n",#name, name->len, name->len, &name->body);
#define __print_BYTE(name) printf("  %s = (BYTE) 0x%2.2x\n",#name, name);
#define __print_WORD(name) printf("  %s = (WORD) 0x%4.4x\n",#name, name);
#define __print_DWORD(name) printf("  %s = (DWORD) 0x%8.8x\n",#name, name);
#define __print_LWORD(name) printf("  %s = (LWORD) 0x%16.16lx\n",#name, name);
/*
 * Functions and variables provied by generated C softPLC
 **/ 
void config_run__(int tick);
void config_init__(void);

/*
 *  Functions and variables to export to generated C softPLC
 **/
 
TIME __CURRENT_TIME;

#define __LOCATED_VAR(type, name, ...) type __##name;
#include "LOCATED_VARIABLES.h"
#undef __LOCATED_VAR
#define __LOCATED_VAR(type, name, ...) type* name = &__##name;
#include "LOCATED_VARIABLES.h"
#undef __LOCATED_VAR

static int tick = 0;

void run()
{
    printf("Tick %d\n",tick);
    config_run__(tick++);
    printf("  Located variables : \n");
#define __LOCATED_VAR(type, name,...) __print_##type(name);
#include "LOCATED_VARIABLES.h"
#undef __LOCATED_VAR
}

```<fitten@refcode>

path: czm2025/matiec/config/INSTALL<fitten@refcode>```Installation Instructions
*************************

Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005,
2006, 2007, 2008, 2009 Free Software Foundation, Inc.

   Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.  This file is offered as-is,
without warranty of any kind.

Basic Installation
==================

   Briefly, the shell commands `./configure; make; make install' should
configure, build, and install this package.  The following
more-detailed instructions are generic; see the `README' file for
instructions specific to this package.  Some packages provide this
`INSTALL' file but do not implement all of the features documented
below.  The lack of an optional feature in a given package is not
necessarily a bug.  More recommendations for GNU packages can be found
in *note Makefile Conventions: (standards)Makefile Conventions.

   The `configure' shell script attempts to guess correct values for
various system-dependent variables used during compilation.  It uses
those values to create a `Makefile' in each directory of the package.
It may also create one or more `.h' files containing system-dependent
definitions.  Finally, it creates a shell script `config.status' that
you can run in the future to recreate the current configuration, and a
file `config.log' containing compiler output (useful mainly for
debugging `configure').

   It can also use an optional file (typically called `config.cache'
and enabled with `--cache-file=config.cache' or simply `-C') that saves
the results of its tests to speed up reconfiguring.  Caching is
disabled by default to prevent problems with accidental use of stale
cache files.

   If you need to do unusual things to compile the package, please try
to figure out how `configure' could check whether to do them, and mail
diffs or instructions to the address given in the `README' so they can
be considered for the next release.  If you are using the cache, and at
some point `config.cache' contains results you don't want to keep, you
may remove or edit it.

   The file `configure.ac' (or `configure.in') is used to create
`configure' by a program called `autoconf'.  You need `configure.ac' if
you want to change it or regenerate `configure' using a newer version
of `autoconf'.

   The simplest way to compile this package is:

  1. `cd' to the directory containing the package's source code and type
     `./configure' to configure the package for your system.

     Running `configure' might take a while.  While running, it prints
     some messages telling which features it is checking for.

  2. Type `make' to compile the package.

  3. Optionally, type `make check' to run any self-tests that come with
     the package, generally using the just-built uninstalled binaries.

  4. Type `make install' to install the programs and any data files and
     documentation.  When installing into a prefix owned by root, it is
     recommended that the package be configured and built as a regular
     user, and only the `make install' phase executed with root
     privileges.

  5. Optionally, type `make installcheck' to repeat any self-tests, but
     this time using the binaries in their final installed location.
     This target does not install anything.  Running this target as a
     regular user, particularly if the prior `make install' required
     root privileges, verifies that the installation completed
     correctly.

  6. You can remove the program binaries and object files from the
     source code directory by typing `make clean'.  To also remove the
     files that `configure' created (so you can compile the package for
     a different kind of computer), type `make distclean'.  There is
     also a `make maintainer-clean' target, but that is intended mainly
     for the package's developers.  If you use it, you may have to get
     all sorts of other programs in order to regenerate files that came
     with the distribution.

  7. Often, you can also type `make uninstall' to remove the installed
     files again.  In practice, not all packages have tested that
     uninstallation works correctly, even though it is required by the
     GNU Coding Standards.

  8. Some packages, particularly those that use Automake, provide `make
     distcheck', which can by used by developers to test that all other
     targets like `make install' and `make uninstall' work correctly.
     This target is generally not run by end users.

Compilers and Options
=====================

   Some systems require unusual options for compilation or linking that
the `configure' script does not know about.  Run `./configure --help'
for details on some of the pertinent environment variables.

   You can give `configure' initial values for configuration parameters
by setting variables in the command line or in the environment.  Here
is an example:

     ./configure CC=c99 CFLAGS=-g LIBS=-lposix

   *Note Defining Variables::, for more details.

Compiling For Multiple Architectures
====================================

   You can compile the package for more than one kind of computer at the
same time, by placing the object files for each architecture in their
own directory.  To do this, you can use GNU `make'.  `cd' to the
directory where you want the object files and executables to go and run
the `configure' script.  `configure' automatically checks for the
source code in the directory that `configure' is in and in `..'.  This
is known as a "VPATH" build.

   With a non-GNU `make', it is safer to compile the package for one
architecture at a time in the source code directory.  After you have
installed the package for one architecture, use `make distclean' before
reconfiguring for another architecture.

   On MacOS X 10.5 and later systems, you can create libraries and
executables that work on multiple system types--known as "fat" or
"universal" binaries--by specifying multiple `-arch' options to the
compiler but only a single `-arch' option to the preprocessor.  Like
this:

     ./configure CC="gcc -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
                 CXX="g++ -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
                 CPP="gcc -E" CXXCPP="g++ -E"

   This is not guaranteed to produce working output in all cases, you
may have to build one architecture at a time and combine the results
using the `lipo' tool if you have problems.

Installation Names
==================

   By default, `make install' installs the package's commands under
`/usr/local/bin', include files under `/usr/local/include', etc.  You
can specify an installation prefix other than `/usr/local' by giving
`configure' the option `--prefix=PREFIX', where PREFIX must be an
absolute file name.

   You can specify separate installation prefixes for
architecture-specific files and architecture-independent files.  If you
pass the option `--exec-prefix=PREFIX' to `configure', the package uses
PREFIX as the prefix for installing programs and libraries.
Documentation and other data files still use the regular prefix.

   In addition, if you use an unusual directory layout you can give
options like `--bindir=DIR' to specify different values for particular
kinds of files.  Run `configure --help' for a list of the directories
you can set and what kinds of files go in them.  In general, the
default for these options is expressed in terms of `${prefix}', so that
specifying just `--prefix' will affect all of the other directory
specifications that were not explicitly provided.

   The most portable way to affect installation locations is to pass the
correct locations to `configure'; however, many packages provide one or
both of the following shortcuts of passing variable assignments to the
`make install' command line to change installation locations without
having to reconfigure or recompile.

   The first method involves providing an override variable for each
affected directory.  For example, `make install
prefix=/alternate/directory' will choose an alternate location for all
directory configuration variables that were expressed in terms of
`${prefix}'.  Any directories that were specified during `configure',
but not in terms of `${prefix}', must each be overridden at install
time for the entire installation to be relocated.  The approach of
makefile variable overrides for each directory variable is required by
the GNU Coding Standards, and ideally causes no recompilation.
However, some platforms have known limitations with the semantics of
shared libraries that end up requiring recompilation when using this
method, particularly noticeable in packages that use GNU Libtool.

   The second method involves providing the `DESTDIR' variable.  For
example, `make install DESTDIR=/alternate/directory' will prepend
`/alternate/directory' before all installation names.  The approach of
`DESTDIR' overrides is not required by the GNU Coding Standards, and
does not work on platforms that have drive letters.  On the other hand,
it does better at avoiding recompilation issues, and works well even
when some directory options were not specified in terms of `${prefix}'
at `configure' time.

Optional Features
=================

   If the package supports it, you can cause programs to be installed
with an extra prefix or suffix on their names by giving `configure' the
option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.

   Some packages pay attention to `--enable-FEATURE' options to
`configure', where FEATURE indicates an optional part of the package.
They may also pay attention to `--with-PACKAGE' options, where PACKAGE
is something like `gnu-as' or `x' (for the X Window System).  The
`README' should mention any `--enable-' and `--with-' options that the
package recognizes.

   For packages that use the X Window System, `configure' can usually
find the X include and library files automatically, but if it doesn't,
```<fitten@refcode>

path: czm2025/matiec/tests/STD_TEST.xml<fitten@refcode>```<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://www.plcopen.org/xml/tc6.xsd"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xsi:schemaLocation="http://www.plcopen.org/xml/tc6.xsd http://www.plcopen.org/xml/tc6.xsd">
  <fileHeader contentDescription="This tests as most as possible IEC standard library"
              companyName="Beremiz"
              companyURL="www.beremiz.org"
              productName="BREMIZ"
              productRelease="1"
              productVersion="1"
              creationDateTime="2007-07-07 11:58:26"/>
  <contentHeader name="STD_TEST">
    <coordinateInfo>
      <fbd>
        <scaling y="0" x="0"/>
      </fbd>
      <ld>
        <scaling y="0" x="0"/>
      </ld>
      <sfc>
        <scaling y="0" x="0"/>
      </sfc>
    </coordinateInfo>
  </contentHeader>
  <types>
    <dataTypes/>
    <pous>
      <pou name="TEST_FROM_STRINGS" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="IN1">
              <type>
                <string/>
              </type>
            </variable>
            <variable name="IN2">
              <type>
                <string/>
              </type>
            </variable>
            <variable name="TESTNR">
              <type>
                <INT/>
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="INTRES">
              <type>
                <INT/>
              </type>
            </variable>
            <variable name="NEXT_TEST">
              <type>
                <INT/>
              </type>
            </variable>
            <variable name="TEST_NAME">
              <type>
                <string/>
              </type>
            </variable>
          </outputVars>
        </interface>
        <body>
          <FBD>
            <inVariable localId="6" width="59" height="27">
              <position y="288" x="34"/>
              <connectionPointOut>
                <relPosition y="13" x="59"/>
              </connectionPointOut>
              <expression>TESTNR</expression>
            </inVariable>
            <outVariable localId="8" width="92" height="47">
              <position y="370" x="826"/>
              <connectionPointIn>
                <relPosition y="23" x="0"/>
                <connection refLocalId="16" formalParameter="OUT">
                  <position y="393" x="826"/>
                  <position y="393" x="809"/>
                  <position y="400" x="809"/>
                  <position y="400" x="792"/>
                </connection>
              </connectionPointIn>
              <expression>INTRES</expression>
            </outVariable>
            <block localId="11" height="114" width="115" instanceName="" typeName="LEN">
              <position y="361" x="325"/>
              <inputVariables>
                <variable formalParameter="IN">
                  <connectionPointIn>
                    <relPosition y="67" x="0"/>
                    <connection refLocalId="24">
                      <position y="428" x="325"/>
                      <position y="428" x="304"/>
                      <position y="416" x="304"/>
                      <position y="416" x="283"/>
                    </connection>
                  </connectionPointIn>
                </variable>
              </inputVariables>
              <inOutVariables/>
              <outputVariables>
                <variable formalParameter="OUT">
                  <connectionPointOut>
                    <relPosition y="67" x="115"/>
                  </connectionPointOut>
                </variable>
              </outputVariables>
            </block>
            <block localId="16" height="240" width="107" instanceName="" typeName="MUX">
              <position y="358" x="685"/>
              <inputVariables>
                <variable formalParameter="K">
                  <connectionPointIn>
                    <relPosition y="42" x="0"/>
                    <connection refLocalId="60" formalParameter="OUT">
                      <position y="400" x="685"/>
                      <position y="400" x="642"/>
                      <position y="338" x="642"/>
                      <position y="338" x="614"/>
                    </connection>
                  </connectionPointIn>
                </variable>
                <variable formalParameter="IN0">
                  <connectionPointIn>
                    <relPosition y="86" x="0"/>
                    <connection refLocalId="11" formalParameter="OUT">
                      <position y="444" x="685"/>
                      <position y="444" x="562"/>
                      <position y="428" x="562"/>
                      <position y="428" x="440"/>
                    </connection>
                  </connectionPointIn>
                </variable>
                <variable formalParameter="IN1">
                  <connectionPointIn>
                    <relPosition y="130" x="0"/>
                    <connection refLocalId="76" formalParameter="OUT">
                      <position y="488" x="685"/>
                      <position y="488" x="534"/>
                      <position y="515" x="534"/>
                      <position y="515" x="467"/>
                    </connection>
                  </connectionPointIn>
                </variable>
                <variable formalParameter="IN2">
                  <connectionPointIn>
                    <relPosition y="174" x="0"/>
                    <connection refLocalId="75" formalParameter="OUT">
                      <position y="532" x="685"/>
                      <position y="532" x="600"/>
                      <position y="599" x="600"/>
                      <position y="599" x="467"/>
                    </connection>
                  </connectionPointIn>
                </variable>
                <variable formalParameter="IN3">
                  <connectionPointIn>
                    <relPosition y="218" x="0"/>
                    <connection refLocalId="57" formalParameter="OUT">
                      <position y="576" x="685"/>
                      <position y="576" x="632"/>
                      <position y="690" x="632"/>
                      <position y="690" x="448"/>
                    </connection>
                  </connectionPointIn>
                </variable>
              </inputVariables>
              <inOutVariables/>
              <outputVariables>
                <variable formalParameter="OUT">
                  <connectionPointOut>
                    <relPosition y="42" x="107"/>
                  </connectionPointOut>
                </variable>
              </outputVariables>
            </block>
            <inVariable localId="23" width="49" height="30">
              <position y="508" x="270"/>
              <connectionPointOut>
                <relPosition y="15" x="49"/>
              </connectionPointOut>
              <expression>IN1</expression>
            </inVariable>
            <inVariable localId="24" width="75" height="33">
              <position y="400" x="208"/>
              <connectionPointOut>
                <relPosition y="16" x="75"/>
              </connectionPointOut>
              <expression>IN1</expression>
            </inVariable>
            <inVariable localId="25" width="71" height="29">
              <position y="562" x="248"/>
              <connectionPointOut>
                <relPosition y="14" x="71"/>
              </connectionPointOut>
              <expression>IN2</expression>
            </inVariable>
            <block localId="57" height="60" width="63" instanceName="" typeName="FIND">
              <position y="660" x="385"/>
              <inputVariables>
                <variable formalParameter="IN1">
                  <connectionPointIn>
                    <relPosition y="30" x="0"/>
                    <connection refLocalId="58">
                      <position y="690" x="385"/>
                      <position y="690" x="371"/>
                      <position y="678" x="371"/>
                      <position y="678" x="347"/>
                    </connection>
                  </connectionPointIn>
                </variable>
                <variable formalParameter="IN2">
                  <connectionPointIn>
                    <relPosition y="50" x="0"/>
                    <connection refLocalId="59">
                      <position y="710" x="385"/>
                      <position y="710" x="371"/>
                      <position y="713" x="371"/>
                      <position y="713" x="348"/>
                    </connection>
                  </connectionPointIn>
                </variable>
              </inputVariables>
              <inOutVariables/>
              <outputVariables>
                <variable formalParameter="OUT">
                  <connectionPointOut>
                    <relPosition y="30" x="63"/>
                  </connectionPointOut>
                </variable>
              </outputVariables>
            </block>
            <inVariable localId="58" width="31" height="27">
              <position y="665" x="316"/>
              <connectionPointOut>
                <relPosition y="13" x="31"/>
              </connectionPointOut>
              <expression>IN1</expression>
            </inVariable>
            <inVariable localId="59" width="31" height="27">
              <position y="700" x="317"/>
              <connectionPointOut>
                <relPosition y="13" x="31"/>
              </connectionPointOut>
              <expression>IN2</expression>
            </inVariable>
            <block localId="60" height="80" width="63" instanceName="" typeName="LIMIT">
              <position y="308" x="551"/>
              <inputVariables>
                <variable formalParameter="MN">
                  <connectionPointIn>
```<fitten@refcode>

path: czm2025/matiec/stage4/generate_c/plc.h<fitten@refcode>```/*
 * (c) 2000 Jiri Baum
 *          Mario de Sousa
 *
 * Offered to the public under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */


#ifndef __PLC_H
#define __PLC_H

#include <stdio.h>  /* required for declaration of FILE */

#ifdef __cplusplus
extern "C" {
#endif


#include "types.h"
#include "log/log.h"
#include "conffile/conffile.h"
#include "cmm/cmm.h"
#include "gmm/gmm.h"
#include "synch/synch.h"
#include "period/period.h"
#include "state/state.h"
#include "rt/rt.h"


#define PLC_PT_NAME_MAX_LEN CMM_NAME_MAX_LEN

/*** GENERAL ***/
int plc_init(char const *module_name, int argc, char **argv);
int plc_done(void);

/*** SYNCHING ***/
int plc_scan_beg(void);
int plc_scan_end(void);

/* memory must be de-allocated with free() */
const char *plc_module_name(void);

/*
 * UTIL functions;
 */
int plc_print_usage(FILE *output);
/* prints the command line arguments the plc_init() function accepts */

/* not to be used by general plc modules. This function is used by the
 * plc_shutdown() function.
 */
int plc_init_try(char const *module_name, int argc, char **argv);


/* plc command line options leader */
#define CLO_LEADER "--PLC"

/* plc command line options */
#define CLO_plc_id             CLO_LEADER "plc_id="
#define CLO_loc_local          CLO_LEADER "local"
#define CLO_loc_isolate        CLO_LEADER "isolate"
#define CLO_loc_shared         CLO_LEADER "shared"
#define CLO_privmap_key        CLO_LEADER "local_map_key="
#define CLO_log_level          CLO_LEADER "debug="
#define CLO_log_file           CLO_LEADER "logfile="
#define CLO_config_file        CLO_LEADER "conf="
#define CLO_module_name        CLO_LEADER "module="
#define CLO_force_init         CLO_LEADER "force-init"


#ifdef __cplusplus
}
#endif

#endif /* __PLC_H */
```<fitten@refcode>

path: czm2025/matiec/absyntax/absyntax.def<fitten@refcode>```/*
 *  matiec - a compiler for the programming languages defined in IEC 61131-3
 *  Copyright (C) 2003-2011  Mario de Sousa (msousa@fe.up.pt)
 *  Copyright (C) 2007-2011  Laurent Bessard and Edouard Tisserant
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/*
 * An IEC 61131-3 compiler.
 *
 * Based on the
 * FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)
 *
 */


/*
 * Definition of the Abstract Syntax data structure components
 */


/*
 * ABSYNTAX.DEF
 *
 * This generates the parse tree structure used to bind the components
 * identified by Bison in the correct syntax order. At the end of the
 * Bison analysis the tree is walked in a sequential fashion generating
 * the relavent code.
 */






/*****************************************************************/
/*****************************************************************/
/*****************************************************************/
/*****************************************************************/
/*                                                               */
/*      safe<xxxxxx> Symbols are defined in:                     */
/*      PLCopen - Technical Committee 5                          */
/*      Safety Software Technical Specification,                 */
/*      Part 1: Concepts and Function Blocks,                    */
/*      Version 1.0 â Official Release - 2006-01-31              */
/*                                                               */
/*****************************************************************/
/*****************************************************************/
/*****************************************************************/
/*****************************************************************/






/*****************************************************************/
/*****************************************************************/
/*****************************************************************/
/*****************************************************************/
/*                                                               */
/*             Symbols defined in:                               */
/*      FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10)          */
/*                                                               */
/*****************************************************************/
/*****************************************************************/
/*****************************************************************/
/*****************************************************************/

/* Based on the                                    */
/* FINAL DRAFT - IEC 61131-3, 2nd Ed. (2001-12-10) */


/* EN/ENO */
/* NOTE we store 'EN' and 'ENO' tokens in an identifier_c
 *      as they may be used as variables, and it is much easier 
 *      to handle them (fewer special cases) if we do it that way...
 */
/*
SYM_REF0(en_param_c)
SYM_REF0(eno_param_c)
*/

/* A class used to identify an entry (literal, variable, etc...) in the abstract syntax tree with an invalid data type */
/* This is only used from stage3 onwards. Stages 1 and 2 will never create any instances of invalid_type_name_c */
SYM_REF0(invalid_type_name_c)



/********************/
/* 2.1.6 - Pragmas  */
/********************/
SYM_REF0(disable_code_generation_pragma_c)
SYM_REF0(enable_code_generation_pragma_c)
SYM_TOKEN(pragma_c)


/***************************/
/* B 0 - Programming Model */
/***************************/
/* enumvalue_symtable is filled in by enum_declaration_check_c, during stage3 semantic verification, with a list of all enumerated constants declared inside this POU */
SYM_LIST(library_c, enumvalue_symtable_t enumvalue_symtable;)


/*************************/
/* B.1 - Common elements */
/*************************/
/*******************************************/
/* B 1.1 - Letters, digits and identifiers */
/*******************************************/
SYM_TOKEN(identifier_c)
/* A special identifier class, used for identifiers that have been previously declared as a derived datatype */
/*  This is currently needed because generate_c stage 4 needs to handle the array datatype identifiers differently to all other identifiers. */
SYM_TOKEN(derived_datatype_identifier_c) 
SYM_TOKEN(poutype_identifier_c) 


/*********************/
/* B 1.2 - Constants */
/*********************/
/*********************************/
/* B 1.2.XX - Reference Literals */
/*********************************/
/* defined in IEC 61131-3 v3 - Basically the 'NULL' keyword! */
SYM_REF0(ref_value_null_literal_c)

/******************************/
/* B 1.2.1 - Numeric Literals */
/******************************/
SYM_TOKEN(real_c)
SYM_TOKEN(integer_c)
SYM_TOKEN(binary_integer_c)
SYM_TOKEN(octal_integer_c)
SYM_TOKEN(hex_integer_c)

/* Note:
 * We do not have signed_integer_c and signed_real_c classes.
 * These are stored in the parse tree as a integer_c or real_c
 * preceded by a unary minus operator if they are inside an expression,
 * or a neg_integer_c and neg_real_c when used outside an ST expression.
 */
/* Not required:
SYM_TOKEN(signed_integer_c)
SYM_TOKEN(signed_real_c)
*/

/* NOTE: literal __values__ are stored directly in classes such as:
 *          - real_c
 *          - integer_c
 *          - binary_integer_c
 *          - etc...
 *
 *       However, for both the real_c and the integer_c, if they are preceded 
 *       by a '-' negation sign, they are further encapsulated inside 
 *       a neg_literal_c (i.e. the neg_literal_c will point to the 
 *       real_c or integer_c with the value being negated.
 *          neg_literal_c -> integer_literal_c
 *                OR
 *          neg_literal_c -> real_literal_c
 *
 *       However, this has since been changed to...
 *        - replace the neg_literal_c with two distinc classes
 *              (neg_integer_c and neg_real_c), one for each
 *              lietral type. 
 *
 *       This change was done in order to ease the writing of semantic verification (stage3) code.
 *       However, that version of the code has since been replaced by a newer and better algoritm.
 *       This means the above change can now be undone, but there is really no need to undo it,
 *       so we leave it as it is.
 */  
SYM_REF1(neg_real_c, exp)
SYM_REF1(neg_integer_c, exp)

/* Not required:
SYM_REF2(numeric_literal_c, type, value)
*/
SYM_REF2(integer_literal_c, type, value)
SYM_REF2(real_literal_c, type, value)
SYM_REF2(bit_string_literal_c, type, value)
/* A typed or untyped boolean literal... */
/* type may be NULL */
SYM_REF2(boolean_literal_c, type, value)

/* helper class for boolean_literal_c */
SYM_REF0(boolean_true_c)

/* helper class for boolean_literal_c */
SYM_REF0(boolean_false_c)


/*******************************/
/* B.1.2.2   Character Strings */
/*******************************/
SYM_TOKEN(double_byte_character_string_c)
SYM_TOKEN(single_byte_character_string_c)


/***************************/
/* B 1.2.3 - Time Literals */
/***************************/

/************************/
/* B 1.2.3.1 - Duration */
/************************/
SYM_REF0(neg_time_c)
SYM_REF3(duration_c, type_name, neg, interval)
SYM_REF5(interval_c, days, hours, minutes, seconds, milliseconds)
SYM_TOKEN(fixed_point_c)
/*
SYM_REF2(days_c, days, hours)
SYM_REF2(hours_c, hours, minutes)
SYM_REF2(minutes_c, minutes, seconds)
SYM_REF2(seconds_c, seconds, milliseconds)
SYM_REF1(milliseconds_c, milliseconds)
*/

/************************************/
/* B 1.2.3.2 - Time of day and Date */
/************************************/
SYM_REF2(time_of_day_c, type_name, daytime)
SYM_REF3(daytime_c, day_hour, day_minute, day_second)
SYM_REF2(date_c, type_name, date_literal)
SYM_REF3(date_literal_c, year, month, day)
SYM_REF3(date_and_time_c, type_name, date_literal, daytime)


/**********************/
/* B.1.3 - Data types */
/**********************/
/***********************************/
/* B 1.3.1 - Elementary Data Types */
/***********************************/
SYM_REF0(time_type_name_c)
SYM_REF0(bool_type_name_c)
SYM_REF0(sint_type_name_c)
SYM_REF0(int_type_name_c)
SYM_REF0(dint_type_name_c)
SYM_REF0(lint_type_name_c)
SYM_REF0(usint_type_name_c)
SYM_REF0(uint_type_name_c)
SYM_REF0(udint_type_name_c)
SYM_REF0(ulint_type_name_c)
SYM_REF0(real_type_name_c)
SYM_REF0(lreal_type_name_c)
SYM_REF0(date_type_name_c)
SYM_REF0(tod_type_name_c)
SYM_REF0(dt_type_name_c)
SYM_REF0(byte_type_name_c)
SYM_REF0(word_type_name_c)
SYM_REF0(dword_type_name_c)
SYM_REF0(lword_type_name_c)
SYM_REF0(string_type_name_c)
SYM_REF0(wstring_type_name_c)
SYM_REF0(void_type_name_c) /* a non-standard extension! */

  /*****************************************************************/
  /* Keywords defined in "Safety Software Technical Specification" */
  /*****************************************************************/

SYM_REF0(safetime_type_name_c)
SYM_REF0(safebool_type_name_c)
SYM_REF0(safesint_type_name_c)
SYM_REF0(safeint_type_name_c)
SYM_REF0(safedint_type_name_c)
SYM_REF0(safelint_type_name_c)
SYM_REF0(safeusint_type_name_c)
SYM_REF0(safeuint_type_name_c)
SYM_REF0(safeudint_type_name_c)
SYM_REF0(safeulint_type_name_c)
SYM_REF0(safereal_type_name_c)
SYM_REF0(safelreal_type_name_c)
SYM_REF0(safedate_type_name_c)
SYM_REF0(safetod_type_name_c)
```<fitten@refcode>

path: czm2025/matiec/lib/sema.txt<fitten@refcode>```(*
 * (c) 2011 Edouard Tisserant
 *
 * Fake semaphore support, for non preemptive implementation.
 *
 *)


FUNCTION_BLOCK SEMA
  VAR_INPUT
    CLAIM : BOOL;
    RELEASE : BOOL;
  END_VAR
  VAR_OUTPUT
    BUSY : BOOL;
  END_VAR
  VAR
    Q_INTERNAL : BOOL;
  END_VAR

  Q_INTERNAL := CLAIM OR ( Q_INTERNAL AND (NOT RELEASE));
  BUSY := Q_INTERNAL;

END_FUNCTION_BLOCK

```<fitten@refcode>

=====RESPONSE======


这个项目是一个IEC 61131-3编程语言的开源编译器，名为MATIEC。它旨在为工业自动化领域中的PLC（可编程逻辑控制器）生成符合IEC 61131-3标准的编程语言的编译器。该项目的主要功能包括：

1. **编译器生成**：MATIEC项目的目标是生成一个开源编译器，用于IEC 61131-3标准定义的编程语言。这些编程语言主要用于工业自动化领域，以编程PLC。

2. **支持的编程语言**：IEC 61131-3标准定义了五种编程语言：
   - **IL（指令列表）**：一种类似于汇编的文本编程语言。
   - **ST（结构化文本）**：一种类似于Pascal的文本编程语言。
   - **FBD（功能块图）**：一种类似于基于小规模集成电路（IC）的电气电路图的图形编程语言。
   - **LD（梯形图）**：一种类似于基于继电器的电气电路图的图形编程语言（用于基本的有线逻辑控制器）。
   - **SFC（顺序功能图）**：一种定义状态机的图形编程语言，主要基于Grafcet（也可以用文本格式表示）。

3. **编译器类型**：MATIEC项目生成了两个编译器（更准确地说是代码转换器，但我们喜欢称之为编译器）：
   - **iec2c**：生成与输入文件中表达的IEC 61131-3代码等效的ANSI C代码。
   - **iec2iec**：生成与输入文件中表达的IEC 61131-3代码等效的IEC 61131-3代码。

4. **编译器架构**：编译器工作在4个（+1个）阶段：
   - **阶段1**：词法分析器 - 使用flex实现（stage1_2/iec_flex.ll）。
   - **阶段2**：语法解析器 - 使用bison实现（stage1_2/iec_bison.yy）。
   - **阶段pre3**：填充符号表 - 符号表将简化在抽象符号树中搜索符号。
   - **阶段3**：语义分析器 - 目前仅进行类型检查。
   - **阶段4**：代码生成器 - 生成ANSI C代码。
   - **阶段5**：二进制代码生成器 - gcc、javac等（未集成到matiec编译器中。必须由用户显式调用）。

5. **数据结构**：在各阶段之间传递的数据结构，存储在全局变量中：
   - 1->2：令牌（int）和令牌值（char *）（在stage1_2/stage1_2_priv.hh中定义）。
   - 2->1：符号表（在util/symtable.[hh|cc]中实现，并在stage1_2/stage1_2_priv.hh中定义）。
   - 2->3：抽象语法树（C++对象树，其类在absyntax/absyntax.hh中定义）。
   - pre3->3,4：全局符号表（在util/[d]symtable.[hh|cc]中定义，并在absyntax_utils/absyntax_utils.hh中声明）。
   - 3->4：抽象语法树（与2->3相同），但现在已注释（即在absyntax树中插入了一些额外数据）。
   - 4->5：包含c、java等程序的文件。

6. **编译器工作流程**：编译器在几个阶段中工作：
   - **阶段1和阶段2**：执行一次传递。此传递将：
     - 进行词法分析。
     - 进行语法分析。
     - 执行absyntax_utils/add_en_eno_param_decl_c访问者类。
   - **阶段Pre3**：执行一次传递。此传递将填充以下符号表：
     - function_symtable：包含所有全局声明的函数POU的符号表。
     - function_block_type_symtable：包含所有全局声明的函数块POU的符号表。
     - program_type_symtable：包含所有全局声明的程序POU的符号表。
     - type_symtable：包含所有用户声明（非基本）数据类型定义的符号表。
     - enumerated_value_symtable：包含为枚举类型声明的所有标识符（值）的符号表。
   - **阶段3**：在几个传递中执行两个算法（流控制分析和数据类型分析）。
   - **阶段4**：有两种可能的实现：
     - iec2c：在一次传递中生成C源代码（stage4/generate_c）。
     - iec2iec：在一次传递中生成IEC61131源代码（stage4/generate_iec）。

7. **其他功能**：
   - 支持文件包含：扩展IEC 61131-3标准语法以允许包含其他文件，使用IEC 61131-3 pragma指令。
   - 支持注释：使用特定的注释状态处理嵌套注释。
   - 支持时间文字：使用特定的时间文字状态解析时间文字。

总的来说，MATIEC项目是一个功能强大的开源编译器，旨在为工业自动化领域的PLC编程提供符合IEC 61131-3标准的编程语言的编译器。

# Question

这个项目可以得到一个抽象语法树。如果将污点分析技术应用到其中？需要做什么？

# Answer

将污点分析技术应用到MATIEC项目中，以分析和检测代码中的潜在安全漏洞或数据流问题，需要进行以下步骤：

### 1. **理解污点分析技术**
污点分析是一种用于检测和防止数据泄露和安全漏洞的技术。它通过跟踪数据流，标记和分析可能被污染的数据（即来自不可信源的数据），并确保这些数据不会被用于敏感操作。

### 2. **扩展抽象语法树（AST）**
在现有的抽象语法树中添加额外的信息，以支持污点分析：

- **污点标记**：在AST的每个节点上添加一个污点标记（taint flag），表示该节点是否包含来自不可信源的数据。
- **数据流信息**：在AST中记录数据流信息，包括数据的来源、流向和使用情况。

### 3. **定义污点源和污点汇**
- **污点源**：定义哪些输入数据被认为是不可信的，例如用户输入、网络数据等。
- **污点汇**：定义哪些操作被认为是敏感的，例如文件写入、数据库操作、系统调用等。

### 4. **实现污点传播规则**
定义污点传播规则，以确定污点如何通过程序传播：

- **基本传播规则**：例如，如果一个变量被污染，那么所有通过该变量计算得到的结果也应被标记为污染。
- **控制流规则**：考虑控制流对污点传播的影响，例如条件语句、循环等。

### 5. **实现污点分析算法**
在MATIEC的编译器中实现污点分析算法，通常在语义分析阶段之后进行：

- **遍历AST**：遍历抽象语法树，根据污点传播规则标记和传播污点。
- **检测污点汇**：在遍历过程中，检测污点汇，如果发现污染数据流向敏感操作，则发出警告或错误。

### 6. **集成到编译器流程中**
将污点分析集成到MATIEC的编译器流程中：

- **阶段3之后**：在语义分析（阶段3）之后，添加污点分析阶段。
- **报告结果**：在编译过程中，输出污点分析的结果，包括潜在的安全漏洞和数据流问题。

### 7. **测试和验证**
- **测试用例**：编写测试用例，验证污点分析的正确性和有效性。
- **性能优化**：确保污点分析不会显著增加编译时间，必要时进行性能优化。

### 8. **文档和用户指南**
- **文档**：编写详细的文档，解释污点分析的工作原理、配置选项和使用方法。
- **用户指南**：提供用户指南，帮助用户理解和使用污点分析功能。

### 示例代码片段
以下是一个简单的示例，展示如何在AST节点中添加污点标记：

```cpp
class symbol_c {
  public:
    bool is_tainted; // 污点标记

    symbol_c(int fl = 0, int fc = 0, const char *ffile = NULL, long int forder=0,
             int ll = 0, int lc = 0, const char *lfile = NULL, long int lorder=0)
      : is_tainted(false) {
      // 其他初始化代码
    }

    // 其他成员函数
};
```

### 污点分析算法示例
以下是一个简单的污点分析算法伪代码：

```cpp
void taint_analysis(symbol_c *ast_root) {
  std::queue<symbol_c*> worklist;
  worklist.push(ast_root);

  while (!worklist.empty()) {
    symbol_c *node = worklist.front();
    worklist.pop();

    // 根据污点传播规则更新污点标记
    if (node->is_tainted) {
      for (auto child : node->children) {
        if (!child->is_tainted) {
          child->is_tainted = true;
          worklist.push(child);
        }
      }
    }

    // 检测污点汇
    if (is_sensitive_operation(node) && node->is_tainted) {
      report_vulnerability(node);
    }
  }
}
```

通过以上步骤，可以将污点分析技术集成到MATIEC项目中，从而增强编译器对潜在安全漏洞的检测能力。

# Question

matiec项目已经可以得到抽象语法树。我现在希望能分析每一个输入数据是受到哪些输入数据影响的，我应该使用什么技术？

# Answer

⚠ 回答被用户取消。

# Question

matiec项目已经可以得到抽象语法树。我现在希望能分析每一个输出数据是受到哪些输入数据影响的，我应该使用什么技术？

# Answer

为了分析每一个输出数据是受到哪些输入数据影响的，可以使用**数据依赖分析**（Data Dependency Analysis）技术。数据依赖分析是一种静态分析技术，用于确定程序中变量之间的依赖关系，特别是输入数据对输出数据的影响。以下是实现这一目标的步骤：

### 1. **理解数据依赖分析**
数据依赖分析旨在识别程序中变量之间的依赖关系。具体来说，它关注的是一个变量的值如何依赖于其他变量的值。对于输入数据和输出数据，数据依赖分析可以帮助我们确定哪些输入数据影响了哪些输出数据。

### 2. **扩展抽象语法树（AST）**
在现有的抽象语法树中添加额外的信息，以支持数据依赖分析：

- **依赖关系信息**：在AST的每个节点上添加依赖关系信息，记录该节点依赖的输入数据。
- **数据流信息**：在AST中记录数据流信息，包括数据的来源、流向和使用情况。

### 3. **定义输入和输出数据**
- **输入数据**：定义哪些变量或数据被认为是输入数据，例如用户输入、配置文件、网络数据等。
- **输出数据**：定义哪些变量或数据被认为是输出数据，例如计算结果、文件输出、数据库操作等。

### 4. **实现数据依赖分析算法**
在MATIEC的编译器中实现数据依赖分析算法，通常在语义分析阶段之后进行：

- **遍历AST**：遍历抽象语法树，根据数据流信息和操作类型，确定每个输出数据依赖的输入数据。
- **记录依赖关系**：在遍历过程中，记录每个输出数据依赖的输入数据。

### 5. **集成到编译器流程中**
将数据依赖分析集成到MATIEC的编译器流程中：

- **阶段3之后**：在语义分析（阶段3）之后，添加数据依赖分析阶段。
- **报告结果**：在编译过程中，输出数据依赖分析的结果，包括每个输出数据依赖的输入数据。

### 6. **测试和验证**
- **测试用例**：编写测试用例，验证数据依赖分析的正确性和有效性。
- **性能优化**：确保数据依赖分析不会显著增加编译时间，必要时进行性能优化。

### 7. **文档和用户指南**
- **文档**：编写详细的文档，解释数据依赖分析的工作原理、配置选项和使用方法。
- **用户指南**：提供用户指南，帮助用户理解和使用数据依赖分析功能。

### 示例代码片段
以下是一个简单的示例，展示如何在AST节点中添加依赖关系信息：

```cpp
class symbol_c {
  public:
    std::set<symbol_c*> dependencies; // 依赖关系信息

    symbol_c(int fl = 0, int fc = 0, const char *ffile = NULL, long int forder=0,
             int ll = 0, int lc = 0, const char *lfile = NULL, long int lorder=0) {
      // 其他初始化代码
    }

    // 其他成员函数
};
```

### 数据依赖分析算法示例
以下是一个简单的数据依赖分析算法伪代码：

```cpp
void data_dependency_analysis(symbol_c *ast_root) {
  std::queue<symbol_c*> worklist;
  worklist.push(ast_root);

  while (!worklist.empty()) {
    symbol_c *node = worklist.front();
    worklist.pop();

    // 根据数据流信息更新依赖关系
    if (is_output_data(node)) {
      for (auto child : node->children) {
        if (is_input_data(child)) {
          node->dependencies.insert(child);
        }
      }
    }

    // 继续遍历子节点
    for (auto child : node->children) {
      worklist.push(child);
    }
  }
}
```

通过以上步骤，可以将数据依赖分析技术集成到MATIEC项目中，从而分析每一个输出数据是受到哪些输入数据影响的。

# Question

上一个回答中写的data_dependency_analysis函数集成到matiec的哪一个阶段，或者放到项目中的哪一个位置？

# Answer

将 `data_dependency_analysis` 函数集成到 MATIEC 项目中，可以放在语义分析阶段之后。具体来说，可以在 `stage3`（语义分析）之后，`stage4`（代码生成）之前进行数据依赖分析。这样可以确保在语义分析完成并且抽象语法树（AST）已经被完全构建和注释后，进行数据依赖分析。

### 具体步骤

1. **修改 `stage3` 阶段**：
   - 在 `stage3` 阶段完成后，确保 AST 已经被完全构建和注释。
   - 调用 `data_dependency_analysis` 函数，对 AST 进行数据依赖分析。

2. **在 `stage3` 阶段之后调用 `data_dependency_analysis`**：
   - 在 `stage3` 阶段的代码中，找到合适的位置调用 `data_dependency_analysis` 函数。

### 示例代码

假设 `stage3` 阶段的代码在 `stage3.cc` 文件中，可以在 `stage3` 阶段完成后调用 `data_dependency_analysis` 函数。

```cpp
// stage3.cc

#include "data_dependency_analysis.h"  // 包含数据依赖分析的头文件

int stage3(symbol_c *tree_root, symbol_c **ordered_tree_root) {
    int error_count = 0;
    error_count += enum_declaration_check(tree_root);
    error_count += flow_control_analysis(tree_root);
    error_count += constant_propagation(tree_root);
    error_count += declaration_safety(tree_root);
    error_count += type_safety(tree_root);
    error_count += lvalue_check(tree_root);
    error_count += array_range_check(tree_root);
    error_count += case_elements_check(tree_root);
    error_count += remove_forward_dependencies(tree_root, ordered_tree_root);

    // 在 stage3 阶段完成后，调用数据依赖分析
    data_dependency_analysis(tree_root);

    if (error_count > 0) {
        fprintf(stderr, "%d error(s) found. Bailing out!\n", error_count);
        return -1;
    }
    return 0;
}
```

### 数据依赖分析函数的实现

在 `data_dependency_analysis.h` 和 `data_dependency_analysis.cc` 文件中实现 `data_dependency_analysis` 函数。

```cpp
// data_dependency_analysis.h

#ifndef DATA_DEPENDENCY_ANALYSIS_H
#define DATA_DEPENDENCY_ANALYSIS_H

#include "absyntax/absyntax.hh"  // 包含抽象语法树的头文件

void data_dependency_analysis(symbol_c *ast_root);

#endif // DATA_DEPENDENCY_ANALYSIS_H
```

```cpp
// data_dependency_analysis.cc

#include "data_dependency_analysis.h"
#include <queue>
#include <set>

void data_dependency_analysis(symbol_c *ast_root) {
    std::queue<symbol_c*> worklist;
    worklist.push(ast_root);

    while (!worklist.empty()) {
        symbol_c *node = worklist.front();
        worklist.pop();

        // 根据数据流信息更新依赖关系
        if (is_output_data(node)) {
            for (auto child : node->children) {
                if (is_input_data(child)) {
                    node->dependencies.insert(child);
                }
            }
        }

        // 继续遍历子节点
        for (auto child : node->children) {
            worklist.push(child);
        }
    }
}

bool is_output_data(symbol_c *node) {
    // 根据具体逻辑判断是否为输出数据
    // 例如，检查节点类型是否为输出变量
    return node->type == OUTPUT_VARIABLE;
}

bool is_input_data(symbol_c *node) {
    // 根据具体逻辑判断是否为输入数据
    // 例如，检查节点类型是否为输入变量
    return node->type == INPUT_VARIABLE;
}
```


如果python和pip版本不对应的话，那么采用以下命令更新一下即可

python3 -m pip install --upgrade pip


