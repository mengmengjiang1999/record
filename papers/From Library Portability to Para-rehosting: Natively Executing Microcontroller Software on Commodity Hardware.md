# From Library Portability to Para-rehosting: Natively Executing Microcontroller Software on Commodity Hardware

论文：From Library Portability to Para-rehosting: Natively Executing Microcontroller Software on Commodity Hardware

rehosting：将MCU软件重新编译，使得在用户态可以执行，根据论文描述，好处有至少3个：

1. 现成的x86动态分析工具可以立即开箱即用。
2. 与在真实的MCU设备上运行相比，可以同时启动多个实例，允许进行可扩展和并行的分析。
3. 商品硬件比MCU设备强大得多。我们可以在更短的时间内执行更多的测试用例。


通过一些人工的工作，可以将MCU移植到特定的主机机器。但是目前存在的困难是：

在MCU工具链中使用的libc（例如newlib和redlib）与像GNU libc这样的完整libc实现相比，设计不同。例如，ARM Mbed OS使用函数software_init_hook()来执行一些针对目标的早期初始化，这在GNU libc中并未定义；
更重要的是，一个单一的库有时与一组支持的操作系统例程混合在一起，这些例程也必须被移植；
这些例程是受调度的。如果不考虑到调用序列，预期的逻辑很容易被违反；
如果重新托管的代码需要访问MCU上的真实硬件，那么在主机上的行为就会变得不可预测。

总之，这些困难使得直接移植代价很高，而且相比之下取得的收益有限，而且不具备可迁移性。


本文提出了pararehosting技术，pararehosting（部分重新托管），旨在使MCU软件重新托管到商品硬件的过程更加顺畅。与特别定制的库移植不同，我们支持完全移植MCU操作系统核心，并允许增量即插即用库移植。具体来说，我们抽象了大多数MCU操作系统遵循的整个机器模型，并使用可移植操作系统接口（POSIX）实现了它（命名为PMCU）。通过一个薄薄的操作系统特定的粘合层，PMCU可以与上层源代码（包括库和任务）一起编译成主机上的普通用户空间程序。PMCU准确地模拟了真实MCU的常见行为。因此，基本的操作系统原语，包括调度、抢占、原子性等，可以自动得到支持。简而言之，就是将以上过程自动化完成。


为了支持特定的硬件外设，我们提出了基于HAL（硬件抽象层）的外设函数替换方法。HAL层允许上层操作系统库以抽象级别而不是硬件级别与硬件设备进行交互。【我们识别出高级HAL函数，并将它们替换为主机上的等效处理器。】这简化了移植工作，并提高了I/O性能。对于每个HAL函数，我们为HAL库定义了一组paraAPIs以供调用。相应地，在主机上实现了后端驱动程序。它可以在不同供应商的多个HAL之间共享。从这个意义上说，我们的设计遵循了准虚拟化的精神，其中客体操作系统必须被明确修改以从后端优化的I/O实现中受益（因此称为部分重新托管）。为了加快新外设的后端开发，我们将常见的HAL函数归类为四种类型（IO、存储、计算加速器和虚拟），并实现了相应的模板。开发者只需要确定适当的外设分类，并快速定制实现。

关于测试：
我们的方法已经针对九种MCU操作系统进行了评估，包括广泛部署的Amazon FreeRTOS、ARM Mbed OS、Zephyr和LiteOS等。我们成功编译并执行了FreeRTOS、ARM Mbed OS、Zephyr和LiteOS分别附带的所有库的84.21%、76.47%、89.47%和63.64%。此外，我们的HAL后端支持NXP和STMicroelectronics设备SDK中的大多数外设。为了证明我们方法在安全测试方面的优越性，我们进一步利用AFL [61]和ASAN [50]测试了Amazon FreeRTOS、ARM Mbed OS、Zephyr和LiteOS生态系统中的几个流行库。
我们的工具帮助我们发现了28个以前未知的错误。我们已经负责任地将它们报告给了受影响的供应商。
在撰写本文时，其中5个已由CVE确认，另外19个已由供应商确认。

总结来说，我们做出了以下贡献。
•我们提出了pararehosting技术，以在商品硬件上本地移植MCU软件。它准确地模拟了常见的MCU行为，并依赖于paraAPIs来支持HAL启用的硬件逻辑。
•我们通过原型化一个基于POSIX的可移植MCU和一组para-APIs（以及后端）来实现pararehosting的思想。我们的原型目前支持包括FreeRTOS、ARM Mbed OS、Zephyr和LiteOS在内的九种MCU操作系统。
•我们使用模糊测试来分析MCU中使用的几种流行库，并识别出了28个以前未知的错误。我们的工具是开源的，可在 https://github.com/MCUSec/para-rehosting 上获取。


## BACKGROUND

### A. Microcontroller Units

直到最近几年，微控制器（MCU）被视为嵌入到其他设备中的专用计算机系统，与个人电脑（PC）或移动设备等通用商品计算系统不同。随着物联网（IoT）的出现，MCU现在被赋予了更多样的任务，并且在成本和功率效率的IoT领域中的许多创新中处于中心地位。
从程序员的角度来看，PC/移动处理器和MCU之间最显著的区别是MCU不支持内存管理单元（MMU）。因此，应用程序代码和操作系统内核代码必须在一个平坦的内存地址空间中混合在一起。我们称生成的可执行二进制文件为固件映像。没有虚拟内存支持，Linux内核无法在MCU上运行。MCU的另一个特点是它们高度异构。
每个MCU可能支持一组不同的外设。这些外设可能是定制的，因此具有不同的规格。


### B. Software Ecosystem for MCUs

目前常见的MCU上的OS有：FreeRTOS，LiteRTOS，Zephyr等等。

软件stack：

Amazon FreeRTOS提供了一个RTOS内核以及许多库/中间件，这些库/中间件使得安全地连接到云或其他设备变得容易。核心是一个RTOS内核，负责任务管理、调度、内存管理、中断管理、消息传递等。任务是RTOS中的基本调度单元，类似于Linux操作系统中的线程。与Linux线程不同，RTOS中的所有任务与内核共享相同的地址空间。
有几个内置任务是由内核自动启动的。它们主要用于系统级事件管理。
有三种类型的库，即通用库、应用库和可移植层库。通用库通过额外的数据结构和函数（如原子操作）扩展了内核的功能。应用库是用于连接和远程管理的独立库，如MQTT和设备影子。通常，一个应用库也充当一个专用的系统任务，为其他任务服务。最后，可移植层库处理设备特定事项。它们作为处理器（例如，ARM和MIPS）和外设（例如，网络）的适配器层。已经官方或非官方地提供了许多不同硬件的端口。在开发一个端口时，开发者只负责实现上层库依赖的一系列下游API。反之，这些下游API必须调用RTOS内核提供的某些上游API来实现其功能。


硬件抽象层（HAL）。
MCU固件中另一个重要的软件组件是由芯片供应商提供的。例如，STM32为每种类型的芯片提供了一个包含低级硬件驱动程序以及硬件抽象层（HAL）的SDK [55]。HAL层充当软件和硬件之间的桥梁。它允许上层库以一般和抽象的级别与硬件设备进行交互，而不是在硬件级别。因此，它被可移植层调用以与外设交互。

## III.OVERVIEW

这一段先给出了一个例子，来说明一个看似简单的网络调度函数，实际上涉及很多底层的硬件操作。


B. Para-rehosting
我们提出pararehosting（部分重新托管）以简化MCU软件移植的复杂性。在pararehosting中，我们在主机机器上提供了模拟处理器和外设行为的通用后端实现。上层软件只需要进行轻微的修改以适应后端。
通过pararehosting，我们可以将整个RTOS逻辑，包括内核、内置任务、普通任务一起编译成一个单一的主机程序。它们共享主机上一个进程的相同虚拟地址空间，就像它们在真实MCU上共享相同的平面物理地址空间一样。
如图2所示，所提出的系统由两个主要组件组成。可移植的MCU（PMCU）是一个主机后端，模拟MCU的通用功能和其上可用的内存资源。它可以轻松地移植到不同的MCU操作系统上。具体来说，PMCU模拟任务调度和系统时钟。它还为MCU操作系统提供基本的同步原语。所有这些功能对于MCU操作系统都是必不可少的。我们的实现是模块化的。每个抽象模块都放置在单独的C源文件中，并在需要时在编译项目期间包含在项目中。对于每个支持的MCU操作系统，都有一个薄的粘合层来适应特定的操作系统需求。此外，我们使用链接器脚本来管理结果程序的布局，使其类似于在真实设备上的布局。有了PMCU，我们可以准确地重新托管一个不依赖于任何特定硬件外设的MCU固件。
另一个组件，称为基于HAL的外设函数替换，处理特定于硬件的外设逻辑。
因此，它解决了硬件依赖性问题。由于HAL从程序员那里抽象出低级硬件细节，我们可以很容易地将其高级功能替换为等效的处理程序。请注意，来自不同供应商的设备的HAL通常是不同的。我们不能简单地实现一个高级替换并将其用于所有设备。我们通过将HAL函数的语义实现为一个通用后端，并要求每个HAL库进行一些手动工作来调用后端驱动程序来解决这个问题。相应地，需要适当调整参数并正确捕获返回值。

## IV.PORTABLE MCU

IV.
可移植的MCU
可移植的微控制器（PMCU）模拟了微控制器（MCU）的通用功能以及其上可用的内存资源。我们的原型使用广泛采用的POSIX接口来模拟抽象的通用功能。通过这种方式，重新托管的固件可以在所有类UNIX系统（包括Linux）上执行和分析。在表VII中，我们总结了将PMCU移植到流行的MCU操作系统所需的更改。它包括可移植层库依赖的上游函数、它们提供的下游函数，以及它们调用的通用后端函数，以实际模拟抽象的MCU。

简而言之就是把MCU的通用功能抽象为POSIX接口，使得可以在类UNIX系统上执行。这一部分就讲了一些在MCU中的常见机制，如何对应到类UNIX系统中。具体而言分为三部分：
第一个是如何抽象硬件，第二个是抽象系统时钟，第三个是关于同步的，最后给出了一个例子。本质上来说还是通过类UNIX系统来对MCU进行模拟，其实也并不能做到每次执行都完全一致，但是对于fuzzing来说并不影响。


### A. 抽象机器功能
1) 任务管理：不同于传统的MCU系统，其中单个任务独占处理器，在物联网时代，各种任务需要同时运行。这就需要一个多程序环境。多任务支持已成为主要MCU操作系统的标准特性，PMCU需要相应地模拟这些特性。
我们使用Linux中的一个进程来模拟整个MCU固件，使用一个线程来模拟一个任务。Linux的线程-进程模型为模拟MCU的任务-固件模型提供了基础。特别是，在Linux中，所有线程共享同一个进程的虚拟内存空间，并且拥有自己的栈。在MCU固件中，所有任务共享同一个MCU的物理内存空间，并拥有自己的栈。
在PMCU中，当MCU操作系统创建一个任务时，就会创建一个pthread（线程），其start_routine（开始例程）被初始化为任务的起始函数。线程切换也因为pthread库负责保存和恢复上下文而得到透明支持。在大多数MCU操作系统中，由于多核支持不成熟[41]，[48]，在特定时间只能执行一个线程。因此，我们需要确保一个线程独占当前进程。
也就是说，尽管概念上有多个线程，但只有一个线程是可运行的。这是通过使用POSIX中的信号和互斥机制的组合实现的。只有持有互斥锁的线程才被允许执行。当当前线程让出或被抢占时，它解锁互斥锁以允许其他线程执行，并通过调用sig_wait()挂起自身。
为了恢复，它必须在相应的信号处理程序中接收信号SIGUSR1并获取相同的互斥锁。
默认情况下，在创建线程时，pthread库会分配一个内存区域用作栈，这超出了控制范围。在第四部分B节中，我们将解释如何确保任务栈的位置在真实MCU的内存映射内。

简而言之就是，使用Linux进程来模拟MCU固件，使用线程来模拟一个task。在MCU操作系统中，特定时间只能支持一个线程。对应地，使用互斥锁机制确保一个线程独占当前进程。

2) 系统时钟：MCU的时间被多个任务同时共享。通常使用一个定时器，称为系统时钟（system tick），来定期调用调度器以切换任务。为了支持抢占，RTOS内核会被一个系统定时器定期唤醒，这在真实的MCU中通常由一个计数器硬件实现。自然地，我们利用POSIX中的系统定时器来定期引发一个定时器信号，以模拟这一过程。具体来说，我们使用setitimer()来定期发送一个SIGVTALRM类型的ITIMER_VIRTUAL信号。
ITIMER_VIRTUAL定时器对进程中所有线程消耗的用用户模式CPU时间进行倒计时。因此，它避免了由于对进程分配的不可预测时间所导致的问题。在SIGVTALRM信号处理程序内部，PMCU调用调度器来恢复下一个任务。请注意，调度算法和任务优先级对PMCU来说完全是透明的。请注意，由于Linux机器上定时器的不可预测行为，我们不能保证每次模拟都产生完全相同的执行路径。在真实设备上也是如此。我们稍后将证明，在实践中，这种非确定性行为并不影响错误发现。


3) 同步原语：同步是操作系统的一个基本原语。一旦违反，执行可能会崩溃。例如，当一个任务进入临界区时，一些RTOS需要禁用中断（包括系统时钟）。如果PMCU允许在临界区内有系统时钟（从而允许任务调度），可能会发生竞态条件。PMCU通过在一个全局变量PMCU_INT_ENABLED中跟踪当前中断状态来模拟禁用中断。
当SIGVTALRM信号发生时，如果PMCU_INT_ENABLED被清除，处理程序会立即返回，并将PMCU_pending变量设置为表明在退出临界区后应该调用调度器。否则，处理程序执行正常的调度过程。此外，PMCU确保它不干扰RTOS内核本身，因为PMCU也需要访问关键的RTOS数据结构。
4) 一个运行示例：在图3中，我们展示了一个MCU操作系统执行的运行示例，包含两个任务。任务1正在执行，直到t0时刻，一个SIGVTALRM信号发生，请求可能的任务切换。然后处理程序介入（由PMCU代表）调用内核中的systick处理程序（t0-t1）。内核中的处理程序选择下一个任务并发送一个信号SIGUSR1（t1-t2）。信号处理程序简单地将对应于被选任务（任务2）的线程调度为可运行（t2-t3）。结果，任务2从t3开始执行。从t4到t7的执行序列不言自明。



### B. 内存布局强制

这部分也是重点

如前所述，重新托管程序的内存布局（包括代码、数据、栈、bss等）与真实设备中的不同。例如，默认的Linux机器上的链接器将x86-32上的代码段从0x08048000开始放置，而x86-64上从0x400000开始（如果未启用PIE），而MCU编译器的链接器通常将代码段从零开始放置。这由一个称为链接器脚本的文件控制。通常，MCU有一个从零开始的闪存存储器和另一个偏移处的独立SRAM。为了能够更准确地捕获由内存错误引起的程序错误行为，我们需要根据MCU中的内存映射放置代码和数据段。我们可以简单地重用MCU固件中可用的链接器脚本，但是出现了三个问题。
首先，Linux程序的栈是由内核分配的，而不是基于链接器脚本。具体来说，栈在x86-32上从0x7FFFFFFF向下增长，在x86-64上从0x7fbFFFFFFF向下增长（不考虑随机化）。
此外，默认的线程栈大小限制为2MB。
这个数字甚至超过了许多MCU上的总SRAM大小。为了解决这个问题，我们用汇编语言实现了一个名为stack_switching(void *newSP, void *newFun)的跳板函数，该函数显式地操作SP寄存器，以便线程使用新指定的栈。
然后它跳转到函数newFun()。我们将新任务的开始例程（比如start_routine()）包装在stack_switching(newSP,start_routine)中，这样函数就将栈切换到基于MCU链接器脚本分配的栈，然后跳转到真正的开始函数start_routine()。我们注意到，使用makecontext/setcontext API也可以达到类似的结果。
其次，MCU操作系统中的堆管理与Linux中的冲突。MCU libc分配器没有实现底层的_sbk()，而是依赖于开发者根据链接器脚本中指定的堆范围提供特定于设备的实现。因此，提供的_sbk()与Linux libc分配器中的冲突。在这里我们有两个选择。首先，我们可以抑制Linux分配器。通过这种方式，我们可以精确地模拟链接器脚本中指定的堆布局。其次，我们可以抑制固件提供的_sbk()并使用Linux版本。通过这种方式，我们牺牲了对内存布局的精确仿真。这可能会导致在错误重现和利用中出现问题。然而，使用Linux分配器允许我们立即获得ASAN的bug发现能力。
一些MCU操作系统（如FreeRTOS和LiteOS）提供了自己的分配器。对于它们，我们也有两大策略；1)我们可以将它们的堆实现替换为Linux上的实现，但牺牲了定制分配器的覆盖范围；2)我们可以保留它们的实现，但牺牲ASAN在堆中发现内存错误的能力。
最后，MCU程序的入口点是函数Reset_Hander()，而不是常规Linux程序中的__start()。__start()执行执行环境的必要初始化，并跳转到main函数，而Reset_Hander()在真实设备的内存映射上初始化模拟的内存，例如将数据段从“flash”复制到“SRAM”。我们保持重新托管程序的入口点为__start()，但在执行main函数之前明确调用修改后的Reset_Hander()。


## V.HAL-BASED PERIPHERAL FUNCTION REPLACEMENT

这部分讲的是关于外设的部分如何在rehosting的时候进行适配。这部分看不懂

A. I/O 外设
I/O 外设通常用于与真实世界通信。这包括 UART（通用异步接收器/发送器）、I2C（互连集成电路）、SPI（串行外设接口）、以太网等。
在这项工作中，我们首先开发了一个通用的 I/O 后端，它透明地将外设 I/O 桥接到主机端的标准 I/O。因此，重新托管的固件将主机控制台作为其 I/O 接口。这种方法对于简单的外设（如通常用于调试输出的 UART）效果很好。
这种方法的另一个好处是，像 AFL 这样的模糊测试工具可以很容易地覆盖 STDIN，向固件执行提供测试用例。
网络。我们观察到网络功能是最广泛使用的 I/O 之一，但是像通用后端那样将网络流量重定向到 STDIO 很少能满足我们的重新托管目的，因为使用网络的库会因为通用后端中缺少协议模拟而阻塞。为了模拟网络接口，我们还开发了一个基于 Packet Capture (PCAP) 库 [31] 的高保真网络后端。它使重新托管的固件能够真正访问互联网。网络驱动程序的最基本任务是初始化网络接口卡（NIC）、通过 NIC 发送传出消息和接收传入消息。PCAP 库使我们能够轻松访问主机上的所有数据包，因此满足了我们的要求。
具体来说，我们提供了三个 para-APIs：HAL_BE_NetworkInit()、HAL_BE_NetworkSend() 和 HAL_BE_NetworkReceive()。它们将由 HAL 库的 IP 层中的相关前端例程调用。函数 HAL_BE_NetworkInit() 使用 PCAP API pcap_open_live() 打开主机机器上的一个实时物理以太网接口，该操作返回与此 NIC 相关联的处理程序。要发送数据包，para-API HAL_BE_NetworkSend() 从提供的数据结构中提取数据包缓冲区指针和数据包长度，然后直接调用 PCAP API pcap_sendpacket() 将数据包输出到以太网。为了接收消息，para-API HAL_BE_NetworkReceive() 被用来调用阻塞式 PCAP API pcap_dispatch() 接收一个数据包。数据包通过调用相应的回调函数重构并传输到 MCU OS 堆栈的上层。

简而言之就是将 MCU 固件的外设 I/O 映射到主机的标准 I/O，特别是控制台。此外，为了支持网络功能的模拟，开发了一个基于 PCAP 库的高保真网络后端，允许固件访问互联网并处理网络数据包。通过这种方式，可以使用模糊测试工具向固件提供输入，并在主机环境中模拟 MCU 外设的行为。

B. 存储外设
存储外设通常用作文件系统的硬件介质，如FAT或littlefs。物联网设备中流行的存储介质包括MMC、NAND、NOR和SD卡。对于这四种存储设备的HAL，我们开发了一个通用的存储后端，它在主机文件系统上操作。我们可以安全地抽象化介质访问特性的细节。具体来说，我们使用一个文件来存储固件的整个文件系统。要挂载介质，会调用para-API HAL_BE_Storage_Init()。它将整个文件内容映射到内存中作为原始介质数据。然后，通过调用HAL_BE_Storage_read()和HAL_BE_Storage_write()进行存储读写操作，这些操作通过读写内存来模拟介质访问。

简而言之：通过文件来存储固件的整个文件系统。在启动的时候会将文件内容映射到内存中，然后通过读写内存来模拟文件访问操作。

C. 计算加速器外设
计算加速器外设提供了流行算法的硬件辅助实现，包括许多加密算法和随机数生成器。我们主要使用OpenSSL库来模拟这些算法，并将结果传递给前端函数。

这个好说，因为Linux端一般都有很多库用于实现。

D. 虚拟外设
虚拟外设通常不执行可能影响固件执行的操作。因此，我们可以安全地向HAL前端返回成功代码，或者如果函数不期望返回值，只返回一个void。这包括PWR（电源控制器）、RCC（复位和时钟控制）、ICACHE（指令缓存）等。

就是只返回true或者void


## VI.EVALUATION

我们在一台运行Ubuntu 16.04操作系统的基于x86的PC上开发了一个pararehosting（部分重新托管）原型。我们的原型支持九种MCU操作系统，包括Amazon FreeRTOS [3]、ARM Mbed OS [8]、Zephyr [57]、华为LiteOS [30]、Atomosher [35]、brtos [24]、f9-kernel [52]、FunkOS [1]和TNeo [19]。对于HAL函数，我们的原型涵盖了NXP和STMicroelectronics SDK中支持的大多数外设。总的来说，PMCU由497行代码（LoC）组成，其中294行用于任务管理，165行用于系统时钟，38行用于同步原语，这些都是与操作系统无关的。每个支持的MCU操作系统的粘合层需要不到50行LoC。
每个HAL后端开发了几十个到几百行LoC。对调用HAL后端的HAL库所做的修改是微不足道的（每个不到30行LoC）。所有细节已经在表VII中针对MCU操作系统和表VIII中针对HALs进行了报告。
我们从四个方面评估了pararehosting。首先，我们评估了pararehosting的重新托管能力。这是从两个维度进行的——MCU生态系统的库支持和HAL中的外设支持。其次，由于这项工作的最终目标是为MCU固件启用安全测试，我们使用现成的模糊测试工具AFL [61]来测试由pararehosting编译的固件逻辑，并与其他解决方案的结果进行了比较。第三，我们展示了它的错误发现能力，并解释了一些在所提出的系统帮助下披露的漏洞。最后，由于架构差异和重新编译，我们设计了一个实验来识别在真实设备上运行相同固件逻辑和使用pararehosting运行的差距。除非另有说明，我们所有的实验都是在配备有Intel Core i7-8700 CPU和8GB DRAM的PC上进行的。


这部分就是说，首先想要支持一个新的MCU操作系统，只需要不到50行代码。


### A. 重新托管能力
这部分测试的是论文给出的原型系统，对于软件栈的支持能力。统计了不同的MCU OS的库信息，并且统计了原型系统支持多少库。可以看出这个比例是非常大的。

本节描述了所提出系统的重新托管能力。如前所述，MCU生态系统通常提供一个全面的软件栈以吸引开发者和制造商。我们从相应的官方文档页面或Github仓库中获取了包括Amazon FreeRTOS、ARM Mbed OS、Zephyr和LiteOS在内的四种代表性MCU操作系统的库信息，并统计了我们的原型支持的库。结果总结在表VI中。我们的原型分别支持FreeRTOS、ARM Mbed OS、Zephyr和LiteOS附带的所有库的84.21%、76.47%、89.47%和63.64%。
我们还总结了两个流行的MCU芯片供应商STMicroelectronics和NXP支持的HAL函数。
这个统计数据表明了我们的原型可以支持多少个外设。结果总结在表VIII中。
在表中，我们还列出了每个外设的相关前端和后端函数。值得一提的是，在将源代码与PMCU和HAL后端粘合后，我们没有发现任何编译失败的情况。特别是，在MCU库中没有发现特定于架构的汇编代码。这部分是因为硬件中立的MCU库已经在MCU生态系统中得到了广泛采用。

### B. Fuzzing Performance

这部分要测试的是，这个工作是否真的可以对fuzzing有所帮助。
挑选了合适的库进行测试，并且详细说明了挑选的标准，总之最后挑中了FreeRTOS+TCP library这个库。
经过测试，fuzzing48小时后，成功复现了FreeRTOS+TCP library已报告bug的13个bug中的9个。

和其他工作进行对比：

1. 与基于仿真的工作进行对比

只考虑了应用程序和MCU库的代码。在所有测试样本中，我们都实现了更高的基本块覆盖率。这可以通过我们的方法带来的巨大加速来解释。

2. Comparison with On-device Analysis

没有基于AFL的模糊测试工具可用于真实设备。作为粗略估计，我们只测试了真实设备模糊测试的开销。我们假设设备上已经有某些机制可以为AFL收集路径覆盖信息，例如ETM [9]。
真实设备的模糊测试开销大致由三部分组成：测试用例生成、测试用例输入和程序执行。在这里，我们只估计了测试用例输入和程序执行的开销，因为所有方法的测试用例生成应该是相同的。我们使用pyOCD [39]控制NXP FRDM-K64F开发板并模拟输入过程。Python脚本将一个已知的测试用例写入板的保留内存区域1,000次。板上的程序在迭代完成后终止。传输1KB的测试用例时，每个测试用例传输大约需要0.23秒。我们还比较了与pararehosting、Zephyr QEMU和FRDM-K64F开发板相同工作负载的执行速度。我们发现FRDM-K64F开发板的执行速度比QEMU慢14倍，比pararehosting慢287倍。总之，真实设备上的模糊测试速度远低于我们的方法和基于仿真的方法。

### C. CVE Analysis
We have found 28 previously-unknown bugs as shown in Table IV. Five of them were confirmed by CVE. For the rest, we have reported them to the manufacturers or vendors and 19 of them have been confirmed at the time of writing.所有的这些错误都是内存错误。

### D. Identifying the Gap
由于存在架构上的差异，在MCU上的行为并不能在类UNIX系统上完全一比一复现。
具体而言，就是将rehosting环境下发现的错误放到真实环境中，看看是否仍然可以触发bug。实验发现bug仍然会触发，只不过不会严重到使得固件立刻崩溃。

这段话主要讨论了在嵌入式系统（特别是MCU设备）上进行模糊测试时，真实设备与模拟环境（如Linux机器）之间存在的错误可观察性差异。研究者们通过实验，尝试更好地理解这种差异，并探索了在真实MCU设备上复现通过pararehosting方法发现的错误的可行性。
研究者们创建了一个包含真实和人造错误的代码片段数据集，并在真实设备上测试了这些错误，以观察它们是否能够被触发。他们发现，尽管在模拟环境中大多数错误可以通过ASAN立即观察到，但在真实设备上，这些错误往往不容易被观察到。文章接着详细讨论了几个具体的错误类型，包括除以零、栈溢出和空指针解引用，并解释了为什么这些错误在真实设备上可能不会立即导致崩溃。
1. **除以零**：在ARM处理器上，默认情况下除以零不会导致崩溃，但可以通过设置特定的寄存器来启用除以零检测。
2. **栈溢出**：在模拟环境中，栈溢出可以被ASAN容易地检测到。在真实设备上，默认配置下固件可能继续执行，但可以通过配置栈溢出检测来缓解这个问题。
3. **空指针解引用**：在模拟环境中，访问零地址的内存总是会导致段错误。但在ARM Cortex-M MCU设备上，从零地址读取是允许的，而写入会导致硬错误。
最后，研究者们指出，由于架构差异，重新托管固件上的漏洞利用证明（PoE）可能不适用于真实设备，而且真实设备上的固件错误可能不会立即导致崩溃，这对于在真实设备上进行错误狩猎带来了挑战。研究者们强调了在固件分析中使用内存检查器的重要性，并指出了在真实设备上复现模糊测试结果的复杂性。


## VII.COMPARISON WITH OTHER WORK

为了检验MCU固件的安全性，已经讨论了几种方法。我们将它们归类为四类。
1) 设备上的分析：这种方法需要真实设备来进行测试。它得到了最真实可信的结果，但可扩展性较差，且缺乏可见性。在裸机上收集执行信息是困难的。
2) 完整仿真：为了克服真实硬件上的性能和可扩展性问题，研究人员提出了使用如QEMU这样的完整仿真器来模拟固件执行。主要挑战是仿真不同的外设，并且已经有一些努力朝着这个目标前进[25]，[28]。理论上，这种方法能够更好地观察固件执行。不幸的是，据我们所知，目前还没有工作能够精确支持以前未知的设备。因此，目前，这种方法只存在于理想化的设置中。
3) 外设转发：作为一种中间地带的解决方案，混合方法将外设访问转发到真实设备，并将固件在仿真器内运行[60]，[43]，[34]。然而，由于依赖真实硬件，性能和可扩展性问题仍未解决。
4) 半重新托管：在像HALucinator [16]这样的半重新托管解决方案中，固件的主要逻辑仍然在仿真器内执行。然而，高级HAL函数被识别出来，并用主机上的重新托管处理器替换。因此，避免了对多样化外设的复杂建模。


四种方式进行对比：

比较。在图4中，我们从不同维度比较了我们的方法（部分重新托管）与现有工作。请注意，到目前为止，还不存在可以精确仿真任意MCU设备的完美完整仿真解决方案。
在性能方面，即使是高端MCU也以较低的频率运行。因此，设备上的测试可能效率较低。此外，真实设备上的并行性有限。要增加一个被测试系统（SUT），必须集成一个新的真实设备，并与其他设备正确协调。对于外设转发，设备的频繁重启和信号转发都是耗时的。基于仿真的方法（包括半重新托管）可以在主机上同时运行多个SUT，但指令翻译会带来不可避免的开销。我们的方法允许在主机上进行本地测试，充分利用了现代硬件的并行性和高性能。
关于软件可测试性，我们指的是观察SUT行为的能力。例如，能够观察到崩溃对于模糊测试至关重要。另一个例子是，收集运行时执行路径可以通过生成高质量的测试用例来辅助模糊测试。为了提高可测试性，通常使用工具。工具允许收集更丰富的上下文信息。在模糊测试中，像ASAN [50]这样的工具可以显著提高崩溃识别能力。在真实设备上，除非有非侵入式的硬件调试功能，如ETM [9]，否则几乎不可能收集固件执行信息。
外设转发、完整仿真和半重新托管都依赖于像QEMU这样的仿真器。有了间接层，可测试性可以大大提高。然而，它仍然无法与本地重新托管相比。具体来说，在实践中，基于仿真的方法只能在被仿真机器的上下文中提取信息，而本地重新托管则可以在程序本身的上下文中收集信息，例如，通过工具。在我们的评估（第VI-C节）中，我们已经展示了ASAN如何提高错误发现能力。除了一个（CVE-2019-17210）之外，我们使用工具识别的所有错误，如果未启用ASAN，这些错误就变得不可见。
在硬件独立性方面，设备上的分析和外设转发都需要真实设备，而部分重新托管和基于仿真的方法不依赖于任何真实设备。因此，它们更具可扩展性。
就代码覆盖率而言，所有方法都可以覆盖硬件独立的代码，这在图1中用红线圈出。然而，由于部分重新托管和半重新托管用本地实现替换了依赖硬件的代码，它们无法发现与低级硬件相关代码（例如，驱动程序）的问题，这在图1中用绿线圈出。


## VIII.RELATED WORK


A. MCU操作系统模拟器
为了为MCU开发者创造一个平滑愉快的体验，一些MCU操作系统提供了一个模拟器，使开发者能够在没有真实硬件的情况下编写、运行和调试代码。通常，采用以下三种方法：
1) 基于Web的模拟器：Mbed OS 5提供了一个基于Emscripten [21]和Node.js的交叉编译模拟器。本质上，C/C++代码被翻译成可以在浏览器上运行的WebAssembly。这种方法提供了最大的便利性，因为开发者不需要安装模拟器环境。然而，它与现有的动态测试工具不兼容。
2) 基于QEMU的仿真器：通常，基于QEMU的仿真器只模拟一个特定的开发板。支持任意开发板需要更多的工程努力，鉴于大量的MCU芯片，这是难以管理的。因此，为了允许开发者充分测试RTOS的API，所提供的仿真板应该模拟广泛支持的外设，实际情况并非如此。
例如，我们发现只有一小部分操作系统API可以在RT-Thread仿真器 [58]上进行测试。基于QEMU的方法与（补丁的）AFL [46]兼容，但速度有所降低。但ASAN无法得到完全支持。这种方法被RT-Thread [58]和Zephyr [63]采用。
3) 本地模拟器：有时，MCU操作系统开发者提供了一个模拟器，当与应用程序和内核一起编译时，可以在主机操作系统上生成一个本地应用程序。这种模拟器通常适应目标MCU操作系统的特定特性，并对其进行了某些优化。引入的优化可能会影响固件的预期行为。例如，为了为开发和调试带来一个确定性环境，Zephyr [47]提供的本地模拟器将本地执行模拟为无限快。结果，中断，包括定时器，不能任意暂停一个线程。如果它们待处理，固件必须明确地取消它们的屏蔽。这表明这种建模无法真实地模拟固件和硬件之间的复杂交互。由并发和调度引起的竞态条件问题无法通过这种方法真实地发现。相反，我们的工作真实地模拟了硬件的非确定性本质，并允许中断在任何时候介入。
因此，它可以捕获各种现实世界的软件问题。
特别定制的模拟器开发没有考虑泛化，开发的模拟器不能适用于另一个MCU操作系统。例如，我们发现Zephyr模拟器有一个硬件模型适配层，它与Zephyr驱动程序深度耦合，因此不能轻易地重用以模拟其他MCU操作系统。我们的工作抽象了硬件的常见行为，并相应地提供了统一的后端来模拟固件执行，最小化了支持其他操作系统所需的重工程努力。此外，部分重新托管不仅使MCU的模拟成为可能，还模拟了外设。最后，部分重新托管与其他本地模拟器共享两个关键优势：1) 提高的执行速度，以实现高效的测试；2) 更好的工具能力，以揭示程序问题。本地模拟器得到NuttX [56]、FreeRTOS [4]、Zephyr [47]等的支持。

B. 通用固件仿真
在P2IM [25]中，作者们提议基于设备数据手册或处理器文档抽象出一个特定类别MCU的模型。然后P2IM使用固件特定信息自动实例化这个抽象模型。因此，P2IM对外围设备设计不敏感，对固件实现是通用的。此外，它将输入从AFL引导，以持续模糊测试被仿真的固件。PRETENDER [28]“学习”原始硬件和固件之间的交互模型，并自动创建外围设备的模型。Laelaps [13]使用符号执行解决类似的问题。HALucinator [16]通过用主机实现替换高级HAL函数来避免外围设备仿真的问题。所有这些解决方案都依赖QEMU进行架构仿真，因此遭受性能低下和可测试性差的问题。由于它们直接测试二进制形式的固件，因此不需要源代码。
从概念上讲，HALucinator和pararehosting都使用本地实现替换HAL函数。然而，动机和方法非常不同。HALucinator直接匹配并钩住二进制中的HAL函数。这对于第三方研究人员在二进制文件中发现错误很有帮助。
为了构建函数匹配数据库，它需要HAL源代码来事先计算底层HAL函数的签名。匹配结果可能会因冲突、缺少函数等原因导致的不准确。
Pararehosting本质上需要源代码，并依赖一些人工努力来制作粘合层。然而，我们通过为流行的HAL提供现成的粘合层来缓解这个问题。对于其他情况，提供了常见的para-APIs和模板。在评估中，我们已经展示了与HALucinator相比，本地重新托管带来的巨大性能优势。此外，我们发现HALucinator中测试的所有样本都是裸机的。HALucinator是否能够处理更复杂的OS库仍然未知。
例如，作者们表示，为了支持RIOT OS，他们不得不手动实现上下文切换作为处理器。为了促进模糊测试，他们还需要编写额外的模块来适应测试用例输入，监控执行结果，增加崩溃可见性（例如，一个类似ASAN的堆内存跟踪器）等。

C. 外设转发
研究人员还提出了一种混合仿真方法，使用真实硬件来处理外设操作。Avatar [60]和Avatar2 [42]提出了一个动态分析框架，该框架在QEMU中执行固件，直到遇到I/O请求。在这种情况下，请求被转发到真实硬件。PROSPECT [32]引入了一种新方法，涉及在模糊测试实验期间部分仿真嵌入式设备的固件。通过转发可能访问外设的系统调用，这种方法可以仿真基于Linux的嵌入式系统。
SURROGATES [34]通过使用定制的、低延迟的FPGA桥接在主机的PCI Express总线和被测试系统之间，改进了Avatar。它还允许仿真器完全访问系统的外设。这些方法仍然依赖于真实硬件，因此不可扩展。性能无法超过基于QEMU或重新托管的解决方案所达到的性能。
D. 固件分析
符号执行通常用于分析MCU固件。FIE [18]利用KLEE [12]符号执行引擎提供了一个可扩展的平台，用于检测固件错误。FIE不模拟硬件交互。也就是说，对外围设备的写入被忽略，读操作返回无约束的符号值。此外，它专门用于MSP430系列微控制器。FirmUSB [29]分析嵌入式USB设备，并使用领域知识加快固件的符号执行。与无约束符号执行相比，FirmUSB可以将性能提高七倍。Inception [17]是另一个基于KLEE的系统，旨在测试完整的固件映像。它符号执行从源代码、汇编和二进制库合并的LLVM-IR。为了处理外设，它要么遵循FIE的方法，要么将读操作重定向到真实设备。Pararehosting和Inception都需要源代码。尽管我们在工作中只使用模糊测试来查找错误，但使用angr [53]等符号执行工具来分析重新托管的程序，甚至使用混合模糊测试 [59]，[54]来提高效率，并没有技术上的障碍。
以前的工作在分析基于Linux的固件方面取得了巨大进展[14]，[64]。高级思路是为所有设备设计一个通用内核。这种方法利用了Linux内核提供的抽象层，但无法适用于内核和任务混合在一起的MCU固件。最后，对于PLC，Almgren等人开发了几个基于变异的和基于生成的模糊测试器，针对各种PLC和智能电表[2]。他们发现了几个已知和未知的拒绝服务漏洞。
E. 操作系统定制
近年来，对更好性能和安全性的需求推动了操作系统定制技术的发展[22]，[37]，[10]，[45]。例如，Exokernel [22]提供了一组最小的硬件级接口，用于在多个应用程序之间多路复用硬件资源。在其之上，每个应用程序实现一个库操作系统（libOS），包括一个定制和优化的操作系统抽象。类似地，Unikernel [37]将一个高度专业化的libOS与应用程序一起编译，移除了商品操作系统中的不必要功能。pararehosting中使用的方法与操作系统设计中的这一新趋势相一致。
具体来说，我们也为MCU操作系统抽象了一组共同且最小的硬件接口。每个MCU操作系统都基于这个共同的硬件接口以不同的方式实现其设计的功能。

## IX.CONCLUSIONS
MCU固件的内部安全测试对物联网安全至关重要。然而，由于测试环境的不同，MCU固件无法使用x86上的复杂工具。
将固件重新编译到本地x86主机可以直接解决这个问题。然而，特别定制的移植工作令人畏惧，容易出错，有时甚至是不可能的。因此，我们提出了pararehosting（部分重新托管）来简化这一过程。可移植的MCU能够模拟MCU的通用功能，而paraAPIs则方便了基于HAL（硬件抽象层）的外设函数替换，以处理外设。直接重新托管MCU操作系统可以解决现有解决方案面临的基本问题（性能、可扩展性和可见性）。我们已经实现了我们的想法，并重新托管了九个MCU操作系统。我们对Amazon FreeRTOS、ARM Mbed OS、Zephyr和LiteOS的库进行了安全测试。这些操作系统附带的大多数库可以通过现成的动态分析工具进行测试，包括AFL和ASAN。我们的实验表明，真实固件中的错误可以在重新托管的固件中复现，并且错误在重新托管的固件中更易于观察。通过使用模糊测试运行我们的工具，已经发现了以前未知的错误。