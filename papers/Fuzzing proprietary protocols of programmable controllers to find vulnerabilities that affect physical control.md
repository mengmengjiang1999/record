# Fuzzing proprietary protocols of programmable controllers to find vulnerabilities that affect physical control

https://www.sciencedirect.com/science/article/pii/S1383762122000625


4.1. Input traffic acquisition

如何获得输入的流量？自动点击控制设备



4.2. Seed and guidance sequence identification

如何从流量中筛选出有用的信息？有用：指的是对设备的控制信息


第4.2节 "Seed and guidance sequence identification"（种子和指导序列识别）详细描述了如何从捕获的原始输入流量中进一步筛选出与设备状态变化相关的消息，并从中选择种子消息以及形成相应的指导序列。以下是该部分的主要内容：

1. **消息筛选**：PCFuzzer需要从捕获的流量中筛选出对设备状态有影响的请求消息，同时过滤掉与状态引导无关的消息，如心跳消息、设备时间读取消息、状态同步消息等，以提高测试效率。

2. **基于字节特征的多步聚类方法**：文章设计了一种基于消息字节特征的多步聚类方法来实现消息筛选。首先，通过计算具有相同长度的消息之间的汉明距离来初始化空字符串，并计算消息得分。

3. **使用DBSCAN密度聚类算法**：为了区分和分离“最重要”的得分类别，利用DBSCAN算法对得分接近的消息进行聚类。

4. **识别无关消息**：通过过滤高密度聚类，识别出无关消息的组。

5. **种子和指导序列的选择**：在筛选出相关消息后，PCFuzzer选择能够激活不同状态的消息作为种子，用于测试。种子的选择基于消息之间的相似性度量，使用汉明距离来衡量。

6. **相似性阈值**：设定了一个相似性阈值，该阈值是过滤分析生成的三元组中的最小数字。

7. **相似性度量**：进一步测量相邻消息的相似性，如果相邻消息的长度太长（超过相似消息长度的两倍），则认为相邻消息是相似的，因为它们可能是状态或文件传输消息。

8. **指导序列的形成**：使用种子消息之前的的消息作为其指导序列，以指导模糊测试过程，并有效探索输入空间。

9. **算法实现**：文章提供了算法（Algorithm 1和Algorithm 2）来描述消息筛选和种子识别的具体步骤。

这一节的核心在于介绍了如何从大量流量中识别出对模糊测试有用的种子消息和指导序列，这些消息将用于后续的模糊测试迭代中，以加速状态恢复过程并提高测试效率。


4.3. Anti-replay circumvention

第4.3节 "Anti-replay circumvention"（绕过重放攻击）讨论了如何在模糊测试过程中有效绕过可编程控制器通信协议中常见的重放攻击防护机制。以下是该部分的主要内容：

1. **重放攻击防护机制**：通信协议通常配备有防止重放攻击的机制，以确保通信的合法性。这些机制对于在状态引导过程中进入特定状态构成了挑战。

2. **系统化总结**：文章系统总结了四种主要的重放防护机制：
   - **序列号**：每个请求消息中的序列号按顺序递增。如果序列号不连续，设备会认为消息无效。
   - **时间戳**：消息的发送时间被编码在内容中，接收方根据预设的超时时间来确定消息的有效性。
   - **会话/连接ID**：在建立会话或执行特定功能时，设备会分配一个随机值作为ID，该ID需要在发送请求消息前填入。
   - **挑战-响应**：在建立连接过程中，设备发送一个随机字符串，通信软件使用内置算法、密钥和字符串计算结果，并将结果作为响应发送回设备，以正确验证响应后建立会话。

3. **实际使用中的防护机制**：文章分析了可编程控制器协议中重放防护机制的实现情况，并指出一些制造商实际上并没有在设备中设计序列号和时间戳字段的验证机制。

4. **绕过策略**：
   - 对于序列号和时间戳机制，可以直接绕过，因为制造商没有设计验证机制。
   - 对于会话/连接ID和挑战-响应机制，PCFuzzer首先通过比较重放消息和原始消息的响应来找到固定的ID字段位置。然后自动发送特定请求以获取ID，并将收到的ID填入后续消息中。
   - 对于挑战-响应机制，PCFuzzer使用逆向工程工具来协助计算结果。

5. **配置文件模板**：为了提高PCFuzzer的可扩展性，文章提供了针对这些机制的配置文件模板，并在模糊测试过程中自动完成相应协议的验证。

6. **人工干预**：对于其他协议，分析师可以通过修改配置文件来完成必要的手动工作。

这一节的核心在于介绍了如何在模糊测试中有效地绕过可编程控制器的重放防护机制，以便能够将设备引导至测试所需的特定状态。

对于不同的协议，可能有不同的绕过方法。PCFuzzer提供了这样一种可扩展性


如何监控异常情况？网络+波形

第4.4节 "Network and physical status monitor"（网络和物理状态监控）描述了如何通过监控设备的网络和物理状态来全面检测嵌入式设备中的异常情况。以下是该部分的主要内容：

1. **网络状态监控**：通过分析网络连接条件和响应消息来确定设备的网络状态。监控模块在模糊测试期间发送SYN、FIN和心跳消息，并使用设备检测消息来获取设备型号和制造商信息。

2. **响应消息的相似性**：利用响应消息的相似性来帮助模糊测试器探索更多的状态。设备给出的不同响应通常意味着设备内部执行了不同的功能或状态。

3. **物理状态监控**：使用数字示波器监控可编程控制器输出模块的信号。信号的变化可以分为两类：
   - **瞬态干扰**：波形瞬间出现台阶或衰减，然后恢复正常，这种变化不会反映在示波器计算的波形参数中。
   - **稳态干扰**：波形发生持久变化，这种变化直接反映在波形参数上（例如频率和峰峰值）。

4. **保守监控策略**：采用保守的监控策略，使用波形参数来确定控制服务的状态。为了避免瞬态干扰产生误报，监控模块使用波形参数来确定是否发生了异常。

5. **示波器设置**：为了便于监控，将可编程控制器设置为工作状态，并输出频率为1 Hz的方波。根据奈奎斯特定律，设置采样频率为信号频率的两倍以上。

6. **异常行为的识别**：通过不同的外部行为来判断是否触发了独特的漏洞，包括：
   - B1：设备无法响应PING。
   - B2：工程软件无法连接到设备。
   - B3：输出信号波形发生变化。
   - B4：计算在触发异常行为后恢复设备所需的成本。

7. **恢复难度等级**：根据设备恢复工作的难度，将恢复过程分为不同的等级，从R1（自动恢复）到R5（需要重新下载固件）。

这一节的核心在于介绍了如何通过监控网络和物理状态来检测可编程控制器中的异常行为，并识别真正的独特漏洞。通过这些监控手段，研究者能够在模糊测试过程中及时发现并响应设备状态的异常变化。

4.5. Unique vulnerability identification

简而言之就是，因为是通过网络包的方式去fuzzing的，需要复现一遍，看看到底是什么引发了漏洞


4.6 实现

用Python实现的


## 测试

####  测试configuration

第5.1节 "Experiment setup"（实验设置）描述了用于评估PCFuzzer有效性和性能的实验环境和配置。以下是该部分的主要内容：

1. **数据集**：选择了市场占有率前六的制造商的15个不同型号或固件版本的可编程控制器作为模糊测试的目标，涉及七种专有协议。

2. **基线比较**：选择了几种现有的模糊测试方法作为基线进行比较，包括Peach、KittyFuzzer、BooFuzz、Pulsar等。这些方法中有些需要依赖协议知识手动构建测试用例生成模板。

3. **配置文件**：为了构建有效的测试用例生成模板，使用了Netzob，这是一个先进的开源协议自动逆向工程工具，用于分析协议语法和状态机。

4. **实验配置**：使用Tektronix DPO 3052数字示波器进行信号采集。执行模糊测试的计算机配置为CPU:i7-8750H @ 2.2 GHz和32GB RAM。

5. **实验目的**：为了证明PCFuzzer在发现可编程控制器中的跨网络-物理漏洞方面的有效性和性能效率。

6. **实验设计**：为了进一步证明PCFuzzer中每个模块的重要性，设置了Naive-PCFuzzer和Unguided-PCFuzzer作为比较。Naive-PCFuzzer不执行消息筛选和选择，直接使用原始流量进行状态引导和模糊测试。Unguided-PCFuzzer不执行状态引导，直接进行模糊测试。

7. **实验监控**：为了公平比较，为每个基线方法添加了网络和物理状态监控。

这一节的核心在于介绍了实验的准备工作，包括测试目标的选择、基线方法的确定、实验环境的配置以及实验的设计和目的，为后续的评估结果提供了基础。

#### 

第5.2节 "Real-world vulnerabilities discovery"（现实世界中的漏洞发现）详细描述了使用PCFuzzer在真实世界的可编程控制器上发现漏洞的过程和结果。以下是该部分的主要内容：

1. **漏洞总数**：PCFuzzer在15个来自市场顶级制造商的不同型号的可编程控制器上总共检测到了26个独特的漏洞。

2. **漏洞影响**：在这些漏洞中，有20个漏洞直接影响了物理世界，包括导致控制服务崩溃的漏洞。

3. **漏洞的严重性**：其中13个漏洞在不影响到网络服务的情况下，能够使控制服务崩溃。这意味着这些漏洞只能通过数字示波器来监控。

4. **远程操作问题**：检测到的16个漏洞在被触发后，不能远程操作将设备恢复到正常工作状态。

5. **漏洞验证**：为了证明发现的漏洞与设备的控制程序无关，研究者在更换不同的控制逻辑后验证了这些漏洞。结果表明，PCFuzzer发现的漏洞在任何控制逻辑下都能导致设备崩溃。

6. **漏洞披露**：研究者将发现的漏洞披露给了相应的制造商。其中，施耐德（Schneider）、西门子（Siemens）和三菱（Mitsubishi）做出了回应。他们总共确认了两个0-day漏洞，两个n-day漏洞，其中一个已在最新版本的设备中被修复。

7. **CNVD编号**：对于30天内未收到回应的漏洞，研究者进一步将其披露给了CNVD（中国国家漏洞数据库）。最终，16个漏洞被分配了CNVD编号，其中4个被评定为高风险漏洞。

8. **漏洞细节**：附录C提供了有关确认漏洞的详细信息，包括不同制造商确认的漏洞编号和描述。

这一节的核心在于展示了PCFuzzer在现实世界设备上发现漏洞的能力，并强调了这些漏洞的严重性，特别是那些能够直接影响物理控制并难以远程恢复的漏洞。同时，也展示了研究者与设备制造商之间的互动以及漏洞披露的过程。



0-day漏洞和n-day漏洞是网络安全领域中的术语，用来描述软件或系统中的安全漏洞，并根据漏洞被公众知晓的时间长短来分类：

1. **0-day漏洞**:
   - 0-day漏洞是指那些软件或系统开发者和安全研究人员尚未发现或尚未公开的漏洞。"Zero day"直译为“零天”，意味着漏洞存在的时间长度为零天，即漏洞从被发现到被利用的时间非常短，有时甚至在被发现之前就已经被利用。攻击者可以利用这些漏洞发起攻击，而软件的开发者还没有机会发布补丁来修复它们。

2. **n-day漏洞**:
   - n-day漏洞（其中n是一个正整数）指的是已经被发现并公开了n天的漏洞。与0-day漏洞不同，n-day漏洞已经为公众所知晓，软件或系统的开发者通常已经或有机会了解到这些漏洞的存在，并可能已经发布了修复这些漏洞的补丁。然而，如果用户或组织没有及时更新他们的软件，攻击者仍然可以利用这些已知的漏洞来发起攻击。

简而言之，0-day漏洞是未知的漏洞，而n-day漏洞是已知的漏洞，但可能还没有被广泛修补。两者都对网络安全构成重大威胁，需要及时的识别、修补和防范措施。



第5.3节 "Efficiency of vulnerability discovery"（漏洞发现的效率）讨论了PCFuzzer在发现漏洞方面的效率，并与其他基线方法进行了比较。以下是该部分的主要内容：

1. **测试目标选择**：为了展示不同方法的效率，研究者选择了每个制造商发现的漏洞数量最多的设备作为测试目标。

2. **测试条件**：考虑到模糊测试的随机性，对不同设备进行了三次24小时的测试，每种方法都进行了测试。

3. **基线方法的配置**：为了公平比较，研究者为KittyFuzzer和BooFuzz选择了不同的变异策略，如整体变异和逐字节变异，并选择了警报数量最多的结果进行比较。

4. **结果比较**：PCFuzzer在相同的时间预算内报告了比基线方法更多的警报。Pulsar没有发现任何异常，因此它和其他没有报告警报的方法没有在图表中显示。

5. **漏洞识别**：在区分警报信息后，PCFuzzer也发现了更多的漏洞。使用“×”标记表示不同漏洞首次被发现的时间。

6. **Naive-PCFuzzer的潜力**：Naive-PCFuzzer有可能发现与PCFuzzer相同的漏洞，但这需要更长的时间。这是由于大量无关消息导致的吞吐量下降。

7. **Unguided-PCFuzzer的局限性**：除非漏洞存在于会话建立阶段，否则Unguided-PCFuzzer很难发现漏洞。否则，由于状态约束，它几乎不可能测试到漏洞程序。

8. **效率评估**：通过选择发现漏洞最多的设备，研究者展示了PCFuzzer在发现漏洞方面的效率。PCFuzzer能够在较短的时间内发现更多的漏洞，这证明了其在漏洞发现方面的高效性。

这一节的核心在于展示了PCFuzzer在实际测试中的高效性，尤其是在与现有方法相比较时，能够更快地发现更多的漏洞。


第5.4节 "Efficiency of traffic processing"（流量处理的效率）讨论了PCFuzzer在处理输入流量方面的效率。以下是该部分的主要内容：

1. **流量获取数量**：在输入流量获取阶段，不同工程软件生成的消息数量大约在700到1500条之间。

2. **流量分析成本**：为了衡量流量处理的效率，研究者在保持连接并嗅探大约20000条消息的情况下评估了流量分析的成本。不同协议的流量处理时间不到两秒。

3. **消息筛选效率**：PCFuzzer能够处理大量消息。在实验中，多步聚类方法能够在不同专有协议的流量中筛选出20%到40%的消息。

4. **筛选方法的有效性**：筛选结果没有引入误报（由于格式相似，具有不同功能的消息将被筛选出来）。筛选后的结果仍然能够完成原始流量的功能，不影响状态转移（例如停止可编程控制器）。

5. **随机筛选的比较**：如果随机筛选10%的消息，重放筛选后的流量将无法完成原始功能，这表明多步聚类方法在筛选消息时是有效的。

6. **种子选择方法**：Naive-PCFuzzer在执行所有测试后，没有发现任何PCFuzzer发现的不同漏洞。

7. **流量处理性能**：通过比较不同方法处理相同流量所需的时间，评估了它们在流量处理方面的性能。

这一节的核心在于展示了PCFuzzer在处理大量输入流量时的高效率，以及其筛选方法在减少无关消息和提高测试效率方面的有效性。通过这种方法，PCFuzzer能够更快地进行状态引导和模糊测试，从而提高发现漏洞的速度。


第5.5节 "Fuzzing throughput"（模糊测试吞吐量）讨论了PCFuzzer在执行模糊测试时发送测试用例的速率，以及与其他方法相比的性能。以下是该部分的主要内容：

1. **吞吐量定义**：吞吐量是指在模糊测试过程中，单位时间内能够发送测试用例的数量。

2. **状态引导的影响**：由于PCFuzzer需要在模糊测试过程中重放消息以引导设备状态，这可能会降低测试的吞吐量。

3. **消息筛选和选择算法**：为了最小化对吞吐量的影响，PCFuzzer设计了消息筛选和选择算法。

4. **性能比较**：使用KittyFuzzer作为基准，计算了每分钟发送测试用例的数量的比例，以评估PCFuzzer与其他方法相比的性能。

5. **测试结果**：在测试开始时，由于没有重放消息，三种方法的吞吐量相同。随着需要重放的消息数量增加，测试用例发送时间间隔变长。完成原始标记的元组测试后，新元组测试的吞吐量会有所提高。

6. **与Naive-PCFuzzer的比较**：与Naive-PCFuzzer相比，PCFuzzer能够减少重放对吞吐量的影响。

7. **与KittyFuzzer的比较**：与KittyFuzzer相比，虽然PCFuzzer的吞吐量有所降低，但状态引导使PCFuzzer能够更快地探索输入空间，从而补偿吞吐量的减少。

8. **测试用例发送速率**：通过比较PCFuzzer和Naive-PCFuzzer的测试用例发送速率，展示了PCFuzzer在保持高效率的同时进行状态引导的能力。

这一节的核心在于展示了PCFuzzer在执行模糊测试时的吞吐量，以及其设计的消息筛选和选择算法如何帮助提高测试效率，即使在需要重放消息以引导设备状态的情况下。

第5.6节 "Vulnerability exploitation"（漏洞利用）讨论了发现的漏洞如何被实际利用来对设备造成影响，以及这些漏洞对现实世界可能带来的不同影响。以下是该部分的主要内容：

1. **漏洞影响**：所有发现的漏洞都可以用来触发设备的崩溃，但它们对现实世界的影响各不相同。对于工业控制系统（ICS）来说，那些导致控制服务崩溃的漏洞比仅影响网络服务的漏洞更为严重。

2. **控制逻辑篡改**：由于控制服务或操作系统内存受损，设备可能无法执行物理控制。如果可以构造有效数据，攻击者可能通过网络通信篡改设备的控制逻辑。

3. **案例研究**：文章通过分析一个特定测试用例，展示了如何通过流量分析和工程软件完成漏洞利用，即使在没有设备调试信息的情况下。

4. **项目文件分析**：研究者分析了能够导致崩溃的测试用例，发现其基于变异的消息包含特定的字节序列和有意义的字符串。通过这些信息，他们提取并解压了设备中的项目文件，这些文件包含控制逻辑。

5. **修改项目文件**：研究者提出了两种修改项目文件的方法：直接修改设备内存中的关键数据，或通过重新下载项目文件来覆盖原始内容。他们选择了第二种方法，因为它分析成本低，适合黑盒操作。

6. **漏洞利用过程**：研究者分析了SRTP协议，并构造了上传请求消息以获取设备中存储的文件。然后，他们使用工程软件解析了这些文件，并更改了计时器参数，重新生成了项目文件，并修改了下载消息中的文件校验和、长度字段和数据字段。

7. **漏洞的实际效果**：通过上述操作，设备输出信号的周期从1秒变为4秒，证明了攻击者可以远程改变设备的控制行为。

8. **自动化攻击流程**：文章提到，通过逆向分析消息和工程软件，可以自动化这一部分工作。已经有相关研究在不依赖官方工程软件的情况下，对西门子项目文件进行反汇编和修改。

这一节的核心在于展示了攻击者如何利用发现的漏洞对可编程控制器进行实际的攻击，并可能导致对现实世界的严重后果。同时，它也强调了自动化攻击流程的可行性和对工业控制系统安全的威胁。


最后一节说明了PCFuzzer在不同供应商的可能自定义的网络协议中，也能通过较少的工作量完成设置



最后的讨论，讲了PCFuzzer的局限性

第6.2节 "Limitations and future work"（局限性和未来工作）讨论了PCFuzzer工具的局限性，并提出了未来研究的方向。以下是该部分的主要内容：

1. **工作流程的手动工作**：PCFuzzer的工作流程需要一些手动工作，例如分析流量和配置文件的修改。

2. **对真实设备的依赖**：PCFuzzer在测试过程中依赖于真实设备，这可能限制了它的可移植性和测试范围。

3. **可扩展性问题**：尽管PCFuzzer展示了在多个协议和设备上的测试能力，但高度定制化和私有化的可编程控制器仍然给漏洞发现工作带来挑战。

4. **仿真方案的需求**：未来的工作计划包括研究具有可移植性和保真度的仿真方案，特别是针对广泛使用的实时操作系统（RTOS）。

5. **实时操作系统的漏洞分析**：计划基于仿真方案，发现并分析基于实时操作系统的二进制程序中的漏洞。

6. **现有技术的限制**：目前的技术无法提供完全虚拟化的高保真仿真技术，这对于某些设备漏洞的发现构成了限制。

7. **未来研究方向**：文章提出了未来研究的方向，包括研究嵌入式设备的二进制程序分析、模糊测试、漏洞分析和利用等。

8. **对现有工作的补充**：未来的工作将补充和扩展现有的研究成果，以提高可编程控制器的安全性。

这一节的核心在于识别了PCFuzzer在当前形式下的限制，并提出了克服这些限制的潜在解决方案和未来的研究方向，以期提高工具的效率和适用范围，并进一步增强工业控制系统的安全性。